<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>暑假小目标</title>
    <link href="/my-summer-2022-goal/"/>
    <url>/my-summer-2022-goal/</url>
    
    <content type="html"><![CDATA[<p>总得给自己找点事做。</p><span id="more"></span><p>每日刷题：</p><ul><li><a href="https://leetcode.cn/problem-list/xb9nqhhg/">剑指Offer</a></li><li>牛客面经</li></ul><p>看书：</p><ul><li><a href="https://apachecn.gitee.io/eloquent-js-3e-zh/">JavaScript 编程精解</a></li><li><a href="https://github.com/zy445566/design-pattern-in-javascript">JavaScript中的设计模式</a></li></ul><p>研究一下：</p><ul><li><p>Vue源码</p></li><li><p>STM32</p></li><li><p>MQTT</p></li><li><p><a href="https://www.infoq.cn/article/react-dom-diff/">diff</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>小目标</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记第一次面试</title>
    <link href="/my-first-interview/"/>
    <url>/my-first-interview/</url>
    
    <content type="html"><![CDATA[<p>这个暑假一个多月，想着好好利用，想着正值秋招提前批，复习一下，打算试试水，能拿到那肯定是极好的，如果有实习机会也不错。看了各大企业的需求，各路大佬们的面经，发现自己项目挺多但基础还是较差。</p><p>闲暇刷公众号，有个以前用过的框架在发文章，翻了翻网站没看到秋招相关的信息，就直接公众号问了下招不招人。没想到这一问还真有回复，要我发一下简历，匆匆忙忙更新了半年没动的简历递上去，然后就安排了面试。</p><p>复习才开始两天，硬着头皮也得上了…</p><p>意外发现面试官是框架作者本人，人很好，没问太基础的东西，但Vue3我也才刚刚用，很多地方没答上来，这才发现自己不是一般的菜。后面hr说面试官对我评价还不错，oc了，问我去不去，我说考虑一下。</p><p>这次面试发现自身很多问题，基础知识不牢固，有项目但没组织好语言描述，拿来主义惯了对框架认知还不够深入，缺乏对大型项目的整体理解，对面试流程还是缺少了解。</p><p>考虑了很久，也问了很多人，最后还是婉拒吧，一个月时间先不考虑实习了，打铁还需自身硬，这个暑假需要好好安排，下一篇发计划。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写一个简单的工具库</title>
    <link href="/codes-generator-js/"/>
    <url>/codes-generator-js/</url>
    
    <content type="html"><![CDATA[<p>这几天在把之前写的一些工具类代码做个库开源出来，第一版自用的实在寒碜，要捯饬捯饬用ts重写一遍。</p><p>代码流程是用tsc转换代码，webpack打包。已经重写了一部分，但测试居然跑不通！一查果然是commonjs和esmodule的锅。</p><p>找了很多办法，发现webpack不能用来转换，这应该是babel的功能。其实webpack也是不需要的，就应该源码提交，方便其他开发者修改，需要压缩代码时他们肯定会用webpack的。</p><p>这个工具的主要功能就是按规则批量生成编码，编码这个词在英语不好翻译，怎么写都觉得会有歧义。其实就是生成很多条字符串，这些字符串有规律，比如<code>[&quot;xxx1&quot;, &quot;xxx2&quot;, &quot;xxx3&quot;, ...]</code>、<code>[&quot;1.0.0&quot;, &quot;1.2.0&quot;, &quot;1.4.0&quot;, ...]</code>、<code>[&quot;peop-A&quot;, &quot;peop-B&quot;, &quot;peop-C&quot;, ...]</code>。</p><p>设计了一套短编码，对应上面三个生成规则：<code>&quot;1:1000:1:x&quot;</code>、<code>&quot;1. 0:9:2&quot;</code>、<code>&quot;peop- A:Z&quot;</code>，每个子规则间用空格分割。</p><p>codes-generator-js：<a href="https://github.com/LeUKi/codes-generator-js">github</a> <a href="https://registry.npmjs.org/codes-generator-js">NPM</a></p><p>写的很乱，以后再优化吧。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吃一蛰长一智</title>
    <link href="/big-regret/"/>
    <url>/big-regret/</url>
    
    <content type="html"><![CDATA[<p>以后搞钱先把合同签了，一个学期时间白搞，暑期找实习的时间也错过了。想象师兄很靠谱，现实甲方很离谱。</p><p>还是个大项目，分手机APP、桌面客户端和服务端。APP是Vue2+Uniapp，客户端是Vue3+Vite，服务端是Koajs+mongoDB。技术用的挺多，当初也是奔着学多点搞的。</p><p>糟心难受，最后把代码开源罢。</p><p><a href="https://github.com/LeUKi/qrhub-app">qrhub-app</a> <a href="https://github.com/LeUKi/qrhub-client">qrhub-client</a> <a href="https://github.com/LeUKi/qrhub-server">qrhub-sever</a></p><p>后面再整理一下核心算法和组件，同样开源了，搞不了钱就搞开源。然后计划下这暑假做什么好。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Cloudflare Workers实现带参数的url重定向</title>
    <link href="/cloudflare-workers-url/"/>
    <url>/cloudflare-workers-url/</url>
    
    <content type="html"><![CDATA[<p>国内的主机绑定域名是需要备案的，不是域名备案，而是网站备案，流程比前者麻烦。通过域名访问没有备案的网站会被强制拦截。纯IP访问是允许的，但谁会记这玩意？<br>整了几个国内的便宜云主机，访问部署的服务还得先ping一下域名，再手打IP访问。这一天我受够了，想了些办法：</p><ul><li>找个小本本</li><li>硬背</li><li>国外主机不需要备案</li><li>第三方短网址跳转</li></ul><p>有钱就没这烦恼了，白嫖怪选第五个，用Cloudflare Workers自己搭短网址服务。</p><p>Cloudflare Workers的免费计划提供了每天10万次调用和每次10ms运行时间的serverless服务，对这个小需求足够了。更好的是，可以绑定域名！</p><p>在Cloudflare中创建一个Worker，在触发器中添加自定义域，绑定到域名就可以通过域名访问这个worker。<br><img src="/../post-images/20220704155446.png" alt="绑定域名"></p><p>在资源标签页中点击快速编辑，将下面的代码CV上去。需要改的只有host和jump变量，优先匹配host内的字段。<br><img src="/../post-images/20220704224501.png" alt="快速编辑"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> host = &#123;<br>    <span class="hljs-comment">// doname.com/cf -&gt; 1.1.1.1:80</span><br>    <span class="hljs-comment">// doname.com/cf:123 -&gt; 1.1.1.1:123</span><br>    <span class="hljs-comment">// doname.com/cf/path -&gt; 1.1.1.1/path</span><br>    <span class="hljs-comment">// doname.com/cf?query=key -&gt; 1.1.1.1?query=key</span><br>    <span class="hljs-string">&#x27;cf&#x27;</span>: <span class="hljs-string">&#x27;1.1.1.1&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">const</span> port = &#123;<br>    <span class="hljs-comment">// doname.com/cf:code -&gt; 1.1.1.1:8443</span><br>    <span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">8443</span>,<br>    <span class="hljs-string">&#x27;jenkins&#x27;</span>: <span class="hljs-number">8081</span>,<br>&#125;<br><span class="hljs-keyword">const</span> jump = &#123;<br>    <span class="hljs-comment">// doname.com/bd -&gt; http://baidu.com  </span><br>    <span class="hljs-string">&#x27;bd&#x27;</span>: <span class="hljs-string">&#x27;http://baidu.com&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">go</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);<br>    <span class="hljs-keyword">const</span> &#123;<br>        protocol,<br>        pathname,<br>        search<br>    &#125; = url;<br>    <span class="hljs-keyword">let</span> u = pathname.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">let</span> t = u.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> k = t[<span class="hljs-number">0</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;:&#x27;</span>) ? t[<span class="hljs-number">0</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>] : t[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> p = t[<span class="hljs-number">0</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;:&#x27;</span>) ? t[<span class="hljs-number">0</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>] : <span class="hljs-string">&#x27;80&#x27;</span><br>    <span class="hljs-keyword">if</span> (host.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>        <span class="hljs-keyword">const</span> destinationURL = protocol + <span class="hljs-string">&#x27;//&#x27;</span> + host[k] + <span class="hljs-string">&#x27;:&#x27;</span> + (<span class="hljs-built_in">isNaN</span>(p) ? port[p] : p) + u.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + search;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">redirect</span>(destinationURL, <span class="hljs-number">301</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jump.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">redirect</span>(jump[k], <span class="hljs-number">301</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;can not 2 go, so u go die.&#x27;</span>, &#123;<br>            <span class="hljs-attr">headers</span>: &#123;<br>                <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html;charset=UTF-8&#x27;</span>,<br>            &#125;,<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">go</span>(event.<span class="hljs-property">request</span>));<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样当我访问 <code>/cf:code/dir/file?data=123</code> 时，就能重定向到 <code>1.1.1.1:8443/dir/file?data=123</code>。果然还是自己的URL好记，配合上内网穿透，终于不会忘记乱七八糟的服务地址了！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloudflare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于v-bind与v-model的父子传参问题</title>
    <link href="/v-bind-and-v-model/"/>
    <url>/v-bind-and-v-model/</url>
    
    <content type="html"><![CDATA[<p>最近用Vue3写一个组件，Vue2都没用熟也硬上了。一个组件越写越大，梳理好逻辑后决定把显示和录入拆分开。</p><p>用第三方组件库太顺手，一开始用的是v-bind的写法。因为v-bind是单向数据流，需要在子组件里用 <code>emit</code> 触发父组件的方法，就和下面的例子一样。</p><iframe style="width:100%;height:400px" src="https://sfc.vuejs.org/#__DEV__eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcbmltcG9ydCBDaGlsZCBmcm9tICcuL2NoaWxkLnZ1ZSdcbmNvbnN0IGNvdW50ID0gcmVmKDApXG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8aDE+di1iaW5kPC9oMT5cbiAgPGgxPnt7IGNvdW50IH19PC9oMT5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJjb3VudCsrXCI+ZmF0aGVyIGFkZDwvYnV0dG9uPlxuICA8Q2hpbGQgOmNvdW50PVwiY291bnRcIiBAY291bnRDaGFuZ2U9XCJjb3VudCsrXCIvPlxuPC90ZW1wbGF0ZT4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3VucGtnLmNvbS9AdnVlL3J1bnRpbWUtZG9tQDMuMi4zNy9kaXN0L3J1bnRpbWUtZG9tLmVzbS1icm93c2VyLmpzXCIsXG4gICAgXCJ2dWUvc2VydmVyLXJlbmRlcmVyXCI6IFwiaHR0cHM6Ly91bnBrZy5jb20vQHZ1ZS9zZXJ2ZXItcmVuZGVyZXJAMy4yLjM3L2Rpc3Qvc2VydmVyLXJlbmRlcmVyLmVzbS1icm93c2VyLmpzXCJcbiAgfVxufSIsImNoaWxkLnZ1ZSI6IjxzY3JpcHQgc2V0dXA+XG5pbXBvcnQgeyByZWYgfSBmcm9tICd2dWUnXG5jb25zdCBwcm9wcz1kZWZpbmVQcm9wcyh7Y291bnQ6TnVtYmVyfSlcbmNvbnN0IGVtaXQgPSBkZWZpbmVFbWl0cyhbJ2NvdW50Q2hhbmdlJ10pXG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8aDE+e3sgcHJvcHMuY291bnQgfX08L2gxPlxuICA8YnV0dG9uIEBjbGljaz1cImVtaXQoJ2NvdW50Q2hhbmdlJylcIj5jaGlsZCBhZGQ8L2J1dHRvbj5cbjwvdGVtcGxhdGU+In0="></iframe>  <p>例子中，无论是从父组件还是子组件修改，都能双向同步。实际项目的逻辑只会更复杂，像这样子把更新的逻辑放到父组件里会显得很割裂，父组件也不应该处理更新的逻辑，而应该把更新的逻辑放到子组件里。</p><p>一开始就是这样写，但越写越难受，然后就在想，有没有一种优雅一点的写法，就像是第三方组件库里实现的。回头找element-ui的源码，发现类似的组件用的是 <code>v-model</code>。恍然大悟！一直都是拿来主义，还真没留意到v-model。</p><p>缝缝补补写了个demo，把v-bind的写法改成v-model，子组件通过 <code>emit</code> 触发 <code>update:count</code> 就可以更新父组件的值了，就像下面的例子一样。</p><iframe style="width:100%;height:400px" src="https://sfc.vuejs.org/#__DEV__eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcbmltcG9ydCBDaGlsZCBmcm9tICcuL2NoaWxkLnZ1ZSdcbmNvbnN0IGNvdW50ID0gcmVmKDApXG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8aDE+di1tb2RlbDwvaDE+XG4gIDxoMT57eyBjb3VudCB9fTwvaDE+XG4gIDxidXR0b24gQGNsaWNrPVwiY291bnQrK1wiPmZhdGhlciBhZGQ8L2J1dHRvbj5cbiAgPENoaWxkIHYtbW9kZWw6Y291bnQ9XCJjb3VudFwiLz5cbjwvdGVtcGxhdGU+IiwiaW1wb3J0LW1hcC5qc29uIjoie1xuICBcImltcG9ydHNcIjoge1xuICAgIFwidnVlXCI6IFwiaHR0cHM6Ly91bnBrZy5jb20vQHZ1ZS9ydW50aW1lLWRvbUAzLjIuMzcvZGlzdC9ydW50aW1lLWRvbS5lc20tYnJvd3Nlci5qc1wiLFxuICAgIFwidnVlL3NlcnZlci1yZW5kZXJlclwiOiBcImh0dHBzOi8vdW5wa2cuY29tL0B2dWUvc2VydmVyLXJlbmRlcmVyQDMuMi4zNy9kaXN0L3NlcnZlci1yZW5kZXJlci5lc20tYnJvd3Nlci5qc1wiXG4gIH1cbn0iLCJjaGlsZC52dWUiOiI8c2NyaXB0IHNldHVwPlxuaW1wb3J0IHsgcmVmLHdhdGNoIH0gZnJvbSAndnVlJ1xuY29uc3QgcHJvcHM9ZGVmaW5lUHJvcHMoe1xuICBjb3VudDp7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gIH1cbn0pXG5jb25zdCBjb3VudCA9cmVmKHByb3BzLmNvdW50KVxud2F0Y2goKCkgPT4gcHJvcHMuY291bnQsICgpID0+IHsgY291bnQudmFsdWUgPSBwcm9wcy5jb3VudCB9KVxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKFtcbiAgICAndXBkYXRlOmNvdW50J1xuXSlcbmZ1bmN0aW9uIGFkZChlKXtcbiAgY291bnQudmFsdWUrK1xuICBlbWl0KCd1cGRhdGU6Y291bnQnLGNvdW50LnZhbHVlKVxufVxuPC9zY3JpcHQ+XG5cbjx0ZW1wbGF0ZT5cbiAgPGgxPnt7IGNvdW50IH19PC9oMT5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJhZGRcIj5jaGlsZCBhZGQ8L2J1dHRvbj5cbiAgXG48L3RlbXBsYXRlPiJ9"></iframe><p>可以看到父组件干净又卫生，写v-model就是为了双向绑定。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再见Gridea，你好Hexo！</title>
    <link href="/Bye-Gridea-Hi-Hexo/"/>
    <url>/Bye-Gridea-Hi-Hexo/</url>
    
    <content type="html"><![CDATA[<p>新的工具，新的开始！</p><span id="more"></span><h1 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h1><p>最近忙课程，买了台二手笔电，全面转战Windows，发现Windows版本的iCloud巨难用。不只是同步慢，因为只做了32位应用，效率极低，后台经常出现莫名其妙的高占用，设置选项极其简陋，设置看不到同步的状态。一些正常的文档还比较好同步，但我放了blog的源代码，小文件几千个直接把应用搞奔溃了！Gridea也不争气，写了内容也发不出去，逼得我走上拆迁道路。</p><h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>用Gridea+iCloud是为了跨设备同步写作，没想到win下的体验非常糟糕。新的blog工具我希望能做到以下几点：</p><ol><li>跨设备写作：起码在PC和mac都能用</li><li>同步方便：Gridea本身不具备，但我希望有，而且最好是git管理</li><li>容易从Gridea迁移：虽然文章不多，但评论、标签、图片的迁移很头疼</li><li>自动部署：最好是一条命令或者一个按钮就能自动生成并上传到网站仓库</li><li>功能兼容：辛辛苦苦写的访客统计项目不能浪费呀，互动内容虽然少但对我很宝贵，一定要能沿用gitalk的数据</li><li>自由：拥抱开源</li></ol><p>最后找到了Hexo，对比了vuepress，发现没什么精力去改底层了，只希望缝缝补补速速上线。主题选择了fluid，功能上挑不出问题，搞迁移也有路子。</p><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>不难，甚至说很简单。文章拖进_post里，图片转移到source目录下，评论改一下issues的tags，修改一下页脚，加上友链信息，一下午搞定。</p><h1 id="跨设备与自动化部署"><a href="#跨设备与自动化部署" class="headerlink" title="跨设备与自动化部署"></a>跨设备与自动化部署</h1><p>Hexo写blog会有两份代码。一份是Hexo项目源代码，全部的变动都在这代码改。另一份是静态blog源代码，由前者生成，需要部署到服务器让人们访问。跨设备需要同步的是前一份代码，自动化部署需要同步的是后一份代码。在之前的写作流中，iCloud做的是前者的工作，Gridea做的是后者的工作。<br>新的方案是都交给git管理，把两个代码提交到同一个仓库的不同分支上，使用Github Actions自动从前一份代码生成后一份代码并完成部署。我把前者取为hexo分支，后者则是main分支。<br>具体做法是在hexo分支中建一个workflows，监听该分支的提交操作，每次提交都会调用Github Actions，调用hexo命令生成静态文件，然后提交到main分支上。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>现在在任意一台电脑上，我只需要拉取仓库，添加文章，测试，提交，就能完成写作和发布。非常方便！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列小结</title>
    <link href="/Maximum-continuous-subsequence/"/>
    <url>/Maximum-continuous-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输出其的和与首尾元素。<br>原题：HDOJ 1231</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划:</p><ul><li><code>dp</code> ：以 <code>a[i]</code> 结尾的最大连续子列和，<code>a[i]</code> 是当前遍历元素</li><li>状态转移方程： <code>dp[i]=max(dp[i-1]+a[i],a[i])</code></li><li>状态初始化：<code>dp[0]=a[0]</code></li></ul><p>一些细节：</p><ul><li>定义变量<code>start</code>、<code>end</code>为子序列的首尾索引值，即最大和是<code>dp[end]</code></li><li>当 <code>dp[i-1]+a[i] &gt; a[i]</code> 且 <code>dp[i] &gt; dp[end]</code>，意味着最大子序列由此开始，即<code>start</code>、<code>end</code>都置当前位<code>i</code></li><li>当 <code>dp[i-1]+a[i] &lt; a[i]</code> 时，意味着当前位纳入最大子序列范围，即<code>end</code>置当前位<code>i</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-type">int</span> k,j;<br>    vector &lt;<span class="hljs-type">int</span>&gt; v;<br>    vector &lt;<span class="hljs-type">int</span>&gt; dp;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        v.<span class="hljs-built_in">clear</span>();<br>        dp.<span class="hljs-built_in">clear</span>();<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            v.<span class="hljs-built_in">push_back</span>((cin&gt;&gt;j,j));<br>        &#125;<br><br>        <span class="hljs-type">int</span> t,start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,max=v[<span class="hljs-number">0</span>],oldlast;<br>        dp.<span class="hljs-built_in">push_back</span>(v[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++) &#123;<br>            oldlast=dp.<span class="hljs-built_in">back</span>();<br>            t=oldlast+v[i];<br>            <span class="hljs-keyword">if</span> (v[i]&gt;t)&#123;<br>                dp.<span class="hljs-built_in">push_back</span>(v[i]);<br>                <span class="hljs-keyword">if</span> (v[i]&gt;dp[end])&#123;<br>                    start=i;<br>                    end=i;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp.<span class="hljs-built_in">push_back</span>(t);<br>                <span class="hljs-keyword">if</span> (t&gt;dp[end])end=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[end]&gt;<span class="hljs-number">0</span>)cout&lt;&lt;dp[end]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[start]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[end]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序小结</title>
    <link href="/quick-sort/"/>
    <url>/quick-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>以序列中某个元素作为标准，使剩下比其小的元素放左边、比其大的元素放右边，然后递归标准元素的左右子序列。</p><h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><ul><li>如何选取标准</li><li>如何形成新序列</li></ul><h1 id="具现"><a href="#具现" class="headerlink" title="具现"></a>具现</h1><p>不同的选取方法有不同的序列形成方法，这里只写简单的做法：</p><p>始终选取第一个元素作为标准，顺序遍历后面的值，当值小于标准值时，将该元素置前，遍历结束后交换标准元素与最后一个小值，递归标准元素的左右子序列。</p><p>更详细的步骤：</p><p>第一个元素作为标准，定义i指向第一个元素、j指向第二个元素，j向后遍历，当j元素小于标准值时，先i自增再交换i、j元素，当j遍历完成，交换第一个元素与i元素，i的左右子序列继续递归，直到剩下一或零个元素。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>为什么定义i指向第一个元素？<ul><li>i本质指向的是左子序列的尾元素，默认左子序列是空的。</li><li>当出现比标准小的元素时，先i自增意味着腾出了左子序列的空间，后交换意味着大小元素正确置位。</li><li>第一个元素是标准元素不属于左子序列，即i的默认指向不会造成任何歧义。</li></ul></li><li>当j遍历完成后为什么要交换？<ul><li>遍历完成意味着左右子序列已被找出，将标准元素与左子序列尾元素交换意味着标准元素正确置位。</li></ul></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">114514</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i=l,j=l+<span class="hljs-number">1</span>,t;<br>    <span class="hljs-type">int</span> pivot=arr[l];<span class="hljs-comment">//标准</span><br>    <span class="hljs-keyword">for</span> (;j &lt;= r; ++j) &#123;<span class="hljs-comment">//j遍历</span><br>        <span class="hljs-keyword">if</span> (arr[j]&lt;pivot)&#123;<br>            i++;<span class="hljs-comment">//i自增</span><br>            t=arr[i];<br>            arr[i]=arr[j];<br>            arr[j]=t;<span class="hljs-comment">//交换i与j元素</span><br>        &#125;<br>    &#125;<br>    t=arr[i];<br>    arr[i]=arr[l];<br>    arr[l]=t; <span class="hljs-comment">//交换第一个与i元素</span><br>    <span class="hljs-keyword">if</span>(i-l&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">//剩下两个及以上元素时递归</span><br>        <span class="hljs-built_in">qs</span>(l,i<span class="hljs-number">-1</span>); <span class="hljs-comment">//左子序列</span><br>    <span class="hljs-keyword">if</span>(r-i&gt;<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">qs</span>(i+<span class="hljs-number">1</span>,r); <span class="hljs-comment">//右子序列</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01背包问题小结</title>
    <link href="/0-1-knapsack/"/>
    <url>/0-1-knapsack/</url>
    
    <content type="html"><![CDATA[<p>先上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> M,N;<br>    cin&gt;&gt;M&gt;&gt;N;<br>    <span class="hljs-type">int</span> W[N],C[N];+_<br>    <span class="hljs-type">int</span> dp[N][M+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//接收</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        cin&gt;&gt;W[i]&gt;&gt;C[i];<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; M+<span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (W[<span class="hljs-number">0</span>]&lt;=i)dp[<span class="hljs-number">0</span>][i]=C[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//dp</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M+<span class="hljs-number">1</span> ;++j) &#123;<br>            <span class="hljs-keyword">if</span> (j&lt;W[i]) &#123; dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; &#125;<br>            <span class="hljs-keyword">else</span> &#123; dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - W[i]] + C[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="hljs-comment">//        for (int j = 0; j &lt; M+1 ;++j) &#123;</span><br><span class="hljs-comment">//            cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        cout&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    cout&lt;&lt;dp[N<span class="hljs-number">-1</span>][M];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dp[i][j]</code> 表示从下标为 <code>0</code> ~ <code>i</code> 的物品里任意取，放进容量为 <code>j</code> 的背包，价值总和最大是多少。</p><p>每次放进一个物品，每次增加一个背包容量，当物品放不进背包（<code>j&lt;W[i]</code>）时，取放进物品前的最好值（即<code>dp[i-1][j]</code>）。即在图中取上一格的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (j&lt;W[i]) &#123; dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; &#125;<br></code></pre></td></tr></table></figure><p>当物品可以放进背包时，考虑放与不放。</p><ul><li>不放：价值取图中上一格的值（即<code>dp[i-1][j]</code>）。</li><li>放：价值取下面两者的和：<ul><li>该物品的价值（即<code>C[i]</code>）。</li><li>先放进该物品后剩余的背包空间（<code>[j - W[i]</code>）与 不放该物品情况（<code>[i - 1]</code>） 下的值（<code>dp[i - 1][j - W[i]</code>）。后者是先前计算好的最优值，所以整体肯定是最优解。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = <br>    <span class="hljs-built_in">max</span>(<br>        dp[i - <span class="hljs-number">1</span>][j], <span class="hljs-comment">//不放</span><br>        dp[i - <span class="hljs-number">1</span>][j - W[i]] + C[i] <span class="hljs-comment">//放</span><br>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>01背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hadoop伪分布式从零配置记录</title>
    <link href="/hadoop-zero-to-one/"/>
    <url>/hadoop-zero-to-one/</url>
    
    <content type="html"><![CDATA[<p>大数据课给的虚拟机文件只能在win上使用，其他系统引导都进不去，琢磨下怎么从零配置。</p><p>虚拟机系统：Ubuntu 20.04.4</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>去镜像站下载比较快</p><h2 id="jdk-8u321-linux-x64-tar-gz"><a href="#jdk-8u321-linux-x64-tar-gz" class="headerlink" title="jdk-8u321-linux-x64.tar.gz"></a>jdk-8u321-linux-x64.tar.gz</h2><p>解压到<code>/usr/local</code>，命名为java8</p><h2 id="hadoop-3-2-3-tar-gz"><a href="#hadoop-3-2-3-tar-gz" class="headerlink" title="hadoop-3.2.3.tar.gz"></a>hadoop-3.2.3.tar.gz</h2><p>解压到<code>/usr/local</code>，命名为hadoop</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统新建了一个名为hadoop的账户，试了好多错，就按这样来吧</p><h2 id="x2F-bashrc"><a href="#x2F-bashrc" class="headerlink" title="~&#x2F;.bashrc"></a>~&#x2F;.bashrc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_HOME=/usr/local/hadoop<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br><span class="hljs-built_in">export</span> HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> YARN_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/sbin:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br><span class="hljs-built_in">export</span> HADOOP_INSTALL=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java8<br><span class="hljs-built_in">export</span> JRE_HOME=<span class="hljs-variable">$JAVA_HOME</span>/jre<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$CLASSPATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/lib:<span class="hljs-variable">$JRE_HOME</span>/lib<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin<br></code></pre></td></tr></table></figure><h2 id="安装jre"><a href="#安装jre" class="headerlink" title="安装jre"></a>安装jre</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install default-jre<br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="x2F-usr-x2F-local-x2F-hadoop-x2F-etc-x2F-hadoop-x2F"><a href="#x2F-usr-x2F-local-x2F-hadoop-x2F-etc-x2F-hadoop-x2F" class="headerlink" title="&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;"></a>&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;</h2><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Abase for other temporary directories.<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///usr/local/hadoop/tmp/dfs/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///usr/local/hadoop/tmp/dfs/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///usr/local/hadoop/tmp/dfs/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///usr/local/hadoop/tmp/dfs/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.http.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0.0.0.0:50070<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java8<br></code></pre></td></tr></table></figure><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop namenode -format<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近况小结</title>
    <link href="/2022-03-21/"/>
    <url>/2022-03-21/</url>
    
    <content type="html"><![CDATA[<p>跨个年好久没发文章，写一下近况</p><ul><li>专业课：学jsp、大数据和网络安全，这些大课又砖又硬，还得好好应付</li><li>CTF：闲暇报的，娱乐放松下，后面会更忙，题目能有趣点就好</li><li>蓝桥杯：希望能到国赛，这回好好准备了下STL，应该会比上一次纯暴力解题成绩更好</li><li>上位机项目：被高手带了下，用之前浅学的react和electron搞个前端项目，对接python算法和硬件层，难度有点大</li></ul><p>顺序排越后越重要哈哈哈</p><p>搞上位机项目过程中用到redux，原本还以为是和react一伙的。认真学后感触很深，没想到状态管理还能玩出花来，其中的编程思想也很独特，有时间我要专门写一篇记录下。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>针对 TQ210 的 Linux 内核裁剪补充</title>
    <link href="/TQ210-linux-kernel-clipping/"/>
    <url>/TQ210-linux-kernel-clipping/</url>
    
    <content type="html"><![CDATA[<blockquote><p>又啃了一星期网络垃圾，想走的已成末路，记录下</p></blockquote><p>接 <a href="https://lafish.fun/linux-kernel-clipping/">Linux内核裁剪</a>，当时用的是稍微新一点的 Linux 版本，内核是裁出来了，但测试根本启动不了。</p><p>结果这几天反复测试，应该是没有相关驱动的问题，但用天堑（这板子的开发商）提供源代码编译就没问题。这里给出”正常“流程。</p><h1 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h1><p>天堑提供的源代码是 3.0.8 的，之前安装的 arm-linux-guneabi-gcc 版本太新，所以不能编译旧的内核代码。下面出现的很多报错，都是编译工具太新导致的。</p><p><img src="/../post-images/1636951947003.png"></p><p><img src="/../post-images/1636951961721.png"></p><p>天堑友好地提供了 4.4.6 的编译工具源码，可以编译 3.0.8 的内核，只需要以下几步就能使用。</p><ol><li>代码准备：将 <code>天嵌官方资料/Linux平台工具/4.4.6_TQ210_release_20120720.tar.bz2</code> 解压到 <code>/home/lafish/</code></li></ol><p><img src="/../post-images/1636951983455.png"></p><ol start="2"><li><p>添加环境变量：打开 <code>/home/lafish/.bashrc</code> 文件，最后加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/home/lafish/4.4.6/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li><p>使环境变量生效：终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /home/lafish/.bashrc<br></code></pre></td></tr></table></figure></li><li><p>测试：开一个新终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arm-linux-gcc -v<br></code></pre></td></tr></table></figure><p>正常情况会显示如果显示 <code>gcc version 4.4.6 (for TQ210 Embedsky Tech)</code> ，不正常会显示找不到文件和目录。</p><p>不正常的原因是没有安装32位支持的库，可以用以下命令解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install lib32z1<br></code></pre></td></tr></table></figure><p>很不凑巧，我的系统太新了，<code>lib32z1</code> 的依赖 <code>lib6-i386</code> 的依赖 <code>lib6</code>（你没看错，是依赖的依赖） 版本是最新的 2.32 ，而 <code>lib6-i386</code> 只能依赖 2.31 。很清晰了，得先解决依赖的依赖，才能安装依赖，才能安装 <code>lib32z1</code> ，输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt reinstall libc6=2.31-@ubuntu9<br>sudo apt install libc6-i386<br>sudo apt install lib32z1<br></code></pre></td></tr></table></figure></li></ol><p>至此，环境准备的部分完成了，接下来的过程之前的一样，不同的地方在 Makefile 文件中的 <code>CROSS_COMPILE</code> 字段要赋值 <code>arm-linux-</code>，可能 <code>arm-embedsky-linux-gnueabi-</code> 也是可以的。</p><p>这一次导出的镜像测试就没问题了。</p><p><del>这就是“正常”流程，但很不正常好吧！为什么一定得用它魔改过的 Linux源代码？那 Ubuntu apt 拉取的 5.4 源代码又有什么意义？安装的 arm-linux-guneabi 又有什么用处？代码开源社区都找不到，”正常“流程根本接触不到开源社区，根本体验不到开源成果，捂得实实的，怪不得搞硬件这么赚钱。没有方向的试错就是浪费生命！有这几天我去整新项目不香吗？还有这中文互联网都充斥着什么垃圾，牛头不对马嘴的，广告满天飞，下载开源程序还要注册付费开会员？！</del></p><h1 id="另外一些尝试"><a href="#另外一些尝试" class="headerlink" title="另外一些尝试"></a>另外一些尝试</h1><p>现在已经知道了是驱动缺失导致新内核不能启动，这里尝试将天堑代码里的驱动移植到新内核中，试试能不能在板子上跑新代码。找了一圈，网上的教程都是基于 3.0 内核的，只能自己琢磨了。</p><p>其他驱动可以先放放，串口驱动是一定要先有的，判断能否成功也是从串口读数据。</p><p>通过<a href="http://blog.sina.com.cn/s/blog_bfd2dfb50102wf9d.html">TQ210内核驱动分布</a>这篇官方博客可以看到，串口驱动是 <code>drivers/serial/</code> 下的 <code>s5pv210.c</code> 、<code>samsung.c</code>两个文件。</p><p>在新内核代码 <code>driver/</code> 下创建一个新目录 <code>tq210serial</code> ，将 3.0.8 与 s5pv210、sunsung 相关的文件都丢进去。</p><p>新建 Makefile 和 Kconfig，填充内容：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel"># driver/tq210serial/Kconfig<br><span class="hljs-keyword">menu</span> <span class="hljs-string">&quot;tq&quot;</span><br>config TQ210SERIAL<br>tristate <span class="hljs-string">&quot;Tq210 serial new by lafish&quot;</span><br><span class="hljs-keyword">help</span><br>  Tq210 serial driver<br><br>config TQ210_SERIAL<br>tristate <span class="hljs-string">&quot;tq210 serial new by lafish&quot;</span><br>depends on TQ210SERIAL<br><span class="hljs-keyword">help</span><br>  <span class="hljs-keyword">select</span> it by y<br>endmenu<br><br># driver/tq210serial/Makefile<br>obj-$(TQ210SERIAL)=s5pv210.o<br>obj-$(TQ210SERIAL)=samsung.o<br></code></pre></td></tr></table></figure><p>在上层目录中的 Makefile 和 Kconfig 最后分别加上一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># driver/Kconfig</span><br><span class="hljs-built_in">source</span> <span class="hljs-string">&quot;drivers/tq210serial/Kconfig&quot;</span><br><br><span class="hljs-comment"># driver/Makefile</span><br>obj-$(CONFIG_TQ210SERIAL)+= tq210serial/<br></code></pre></td></tr></table></figure><p>这样就能在配置界面的 <code>Device Driver</code> 最后一项看到新选项了，全部勾选就能把驱动编译进内核。</p><p><img src="/../post-images/1636952013516.png"></p><p><img src="/../post-images/1636952017462.png"></p><p>额外还需要调整内核的启动参数</p><p><img src="/../post-images/1636952126790.png"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>遗憾，这次用手动打驱动编译出的内核还是启动不了。</p><p>可能因为驱动代码移植的是 3.0.8 版本的，当时的编译工具版本对于新代码来说太旧，编译出的 .o 文件不适用于新内核。</p><p>再往下走就要手动改写驱动代码，但这已经大大超出了我目前的技术水平，可能以后会学到，现在的我已经没精力去完善了。</p><p>到头来还是用回了旧版本，跟着人家的教程走。往好处想，我终于可以彻底放弃新内核的探索欲望，投入其他更有意思的项目中去。哈哈哈哈哈哈哈哈哈哈 (-_-) </p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>viewer-catch 基于Koa与MongoDB的站点统计平台</title>
    <link href="/viewer-catch/"/>
    <url>/viewer-catch/</url>
    
    <content type="html"><![CDATA[<blockquote><p>又是一个练手项目。看了一圈实习招聘条件，大多数前端都要掌握一门后台语言，nodejs 当然是前端开发者的首选。初入前端，我以为我能学成全栈，两年过去这才摸到门槛。<del>泪目</del></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于我的静态博客没有动态网站的访客统计功能，之前用的是友盟的站长统计，但这个平台 dns 污染严重，体验不是很好。我想要做一个平台，只要简单的引入就实现任意网站、任意页面的统计功能，还要能在页面中插入统计结果，再做一个点赞的功能就更好了。</p><p>由此 <a href="https://github.com/LeUKi/viewer-catch"><code>viewer-catch</code></a>  <del>（原谅我起名废）</del> 应运而生！</p><h1 id="开始使用！"><a href="#开始使用！" class="headerlink" title="开始使用！"></a>开始使用！</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只需要在网站头部添加这一段代码，每一个页面都能分开统计，还支持区分统计 UV 和 PV ，甚至有点赞统计功能！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://viewer-catch.herokuapp.com/client.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>在指定的地方加上类，它能自动替换统计数据，还能控制隐藏显示！</p><p>如果需要控制显隐 <code>.VCC_before</code> 是必要提前准备的类，推荐是 <code>visibility: hidden;</code> 或者 <code>display: none;</code> ，当数据类替换完成时它会自动去除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"><span class="hljs-selector-class">.VCC_before</span>&#123;<span class="hljs-attribute">visibility</span>: hidden;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 页面UV:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC_uv&#x27;</span>&gt;</span>正在获取<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 页面PV:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC_pv VCC_before&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC_before&#x27;</span>&gt;</span> 页面点赞数:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC_like&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC VCC_before VCC_uv_sum&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC VCC_before VCC_pv_sum&#x27;</span> <span class="hljs-attr">vcc_showin</span>=<span class="hljs-string">&#x27;/&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;VCC VCC_before VCC_like_sum&#x27;</span> <span class="hljs-attr">vcc_hidein</span>=<span class="hljs-string">&#x27;/&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="更简单的使用"><a href="#更简单的使用" class="headerlink" title="更简单的使用"></a>更简单的使用</h2><p>对于不用展示数据、没有统计 UV 需求的网站或页面，以下简单引入是更好的方案。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">sync</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://viewer-catch.herokuapp.com/simpleCatch?d=xxx.com&amp;p=/path&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因标准请求头限制，必须传参使用</p><ul><li>d:Doname 站点域名 必填</li><li>p:Path 页面路径 选填 以 <code>/</code> 开头 缺省为 <code>&quot;/&quot;</code></li></ul><h2 id="更复杂的使用"><a href="#更复杂的使用" class="headerlink" title="更复杂的使用"></a>更复杂的使用</h2><p>项目预留了相关接口，可以访问 <code>/apis</code> 查看接口文档。</p><h1 id="关于平台部署"><a href="#关于平台部署" class="headerlink" title="关于平台部署"></a>关于平台部署</h1><p><code>https://viewer-catch.herokuapp.com/</code> 部署在 Heroku，每个月只有 550 小时的免费时长，数据库则是用的 <code>MongoDB Atlas</code> 的免费套餐 <del>（老白嫖怪了）</del>，如果你条件允许可以自己部署平台。你可以参考这篇文章：<a href="https://lafish.fun/freedom-service/">利用 MongoDB Atlas 与 Heroku 架设 Free 的后台服务</a></p><p><a href="https://dashboard.heroku.com/new?template=https://github.com/LeUKi/viewer-catch"><img src="https://www.herokucdn.com/deploy/button.png" alt="Deploy"></a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 类的继承</title>
    <link href="/learn-javascript-inheritance/"/>
    <url>/learn-javascript-inheritance/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更好的代码复用、扩展，你需要类的继承</p></blockquote><h1 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h1><p>总的来说，ES5 类的继承需要结合对象冒充继承和原型链继承两个方案，下面一一举例。</p><p>想搞继承，首先得有个父类，这里有这么一个构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">//实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; <span class="hljs-comment">//实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//实例方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类描述外部添加了原型方法和静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">swim</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加原型方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is swiming`</span>);<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">work</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is working`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象冒充继承"><a href="#对象冒充继承" class="headerlink" title="对象冒充继承"></a>对象冒充继承</h2><p>这里通过 call 方法继承父类，第一个参数传入子类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, grade</span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age); <span class="hljs-comment">//对象冒充继承</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade; <span class="hljs-comment">//实例属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个对象，发现能继承父类的实例属性和方法，但不能继承原型属性和方法。静态方法也不能被继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;一年级&#x27;</span>); <span class="hljs-comment">//实例化对象</span><br><br><span class="hljs-comment">//继承父类的实例方法</span><br>student1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//张三 is running</span><br><span class="hljs-comment">//不可继承父类的原型方法</span><br><span class="hljs-comment">//student1.swim(); //TypeError: student1.swim is not a function</span><br><span class="hljs-comment">//不可继承父类的静态方法</span><br><span class="hljs-comment">//Student.work(); //TypeError: Student.work is not a function</span><br></code></pre></td></tr></table></figure><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>首先建一个空的子类，将父类的实例赋给子类的 prototype 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Teacher</span>(<span class="hljs-params">name, age, subject</span>) &#123;&#125;<br><br><span class="hljs-title class_">Teacher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">//原型链继承</span><br></code></pre></td></tr></table></figure><p>实例化一个对象，发现可以使用父类的实例方法和原型方法，但 new 实例化传参不可用，需要手动修改实例属性。同时静态方法也不能被继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> teacher1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;语文&#x27;</span>);<span class="hljs-comment">//实例化对象</span><br><br><span class="hljs-comment">//实例属性存在但是没有初始化</span><br>teacher1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//undefined is running</span><br>teacher1.<span class="hljs-title function_">swim</span>(); <span class="hljs-comment">//undefined is swiming</span><br><span class="hljs-comment">//修改实例属性</span><br>teacher1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;王五&quot;</span>; <br>teacher1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//王五 is running</span><br>teacher1.<span class="hljs-title function_">swim</span>(); <span class="hljs-comment">//王五 is swiming</span><br><br><span class="hljs-comment">//不可继承父类的静态方法</span><br><span class="hljs-comment">//Teacher.work(); //TypeError: Teacher.work is not a function</span><br></code></pre></td></tr></table></figure><h2 id="对象冒充-原型链继承"><a href="#对象冒充-原型链继承" class="headerlink" title="对象冒充+原型链继承"></a>对象冒充+原型链继承</h2><p>新建一个子类，通过结合两者实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Programmer</span>(<span class="hljs-params">name, age, language</span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age); <span class="hljs-comment">//对象冒充继承</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">language</span> = language; <span class="hljs-comment">//实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//实例方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.language&#125;</span> developer`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Programmer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">//原型链继承</span><br></code></pre></td></tr></table></figure><p>实例化一个对象，发现可以使用父类的实例方法和原型方法，子类也能向父类传参。但同时静态方法仍然不能被继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> programmer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Programmer</span>(<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>);<span class="hljs-comment">//实例化对象</span><br><br><span class="hljs-comment">//继承父类的实例方法</span><br>programmer1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//赵六 is running</span><br><span class="hljs-comment">//子类方法使用父类的实例属性</span><br>programmer1.<span class="hljs-title function_">introduce</span>(); <span class="hljs-comment">//赵六 is a JavaScript developer</span><br><span class="hljs-comment">//继承父类的原型方法</span><br>programmer1.<span class="hljs-title function_">swim</span>(); <span class="hljs-comment">//赵六 is swiming</span><br><br><span class="hljs-comment">//不可继承父类的静态方法</span><br><span class="hljs-title class_">Programmer</span>.<span class="hljs-title function_">work</span>(); <span class="hljs-comment">//TypeError: Programmer.work is not a function</span><br></code></pre></td></tr></table></figure><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES6 为类的继承提供了好用的语法糖。</p><p>在 class 内，使用 constructor 创建实例属性，用函数创建实例方法，还可以用 static 表示其是静态属性或方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123; <span class="hljs-comment">//实例属性创建</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//实例方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; makes a noise.&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> words = <span class="hljs-string">&#x27;All animals eat food.&#x27;</span>; <span class="hljs-comment">//静态属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时在类描述外部添加了原型方法和静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加原型方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running.&#x27;</span>);<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>建一个子类，通过 extends 关键词继承父类，在 constructor 中的 super 方法类似 ES5 的 call，传入给父类的实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, color</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name, age);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    &#125;<br>    <span class="hljs-title function_">colorIs</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个对象，发现可以使用父类的实例方法和原型方法，子类也能向父类传参。重点是，静态方法在 ES6 上是能被继承的！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Teddy&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;white&#x27;</span>); <span class="hljs-comment">//实例化</span><br><br><span class="hljs-comment">//继承父类的实例方法</span><br>dog1.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">//Teddy makes a noise.</span><br><span class="hljs-comment">//子类方法使用父类的实例属性</span><br>dog1.<span class="hljs-title function_">colorIs</span>(); <span class="hljs-comment">//Teddy is white</span><br><span class="hljs-comment">//继承父类的原型方法</span><br>dog1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//Teddy is running.</span><br><br><span class="hljs-comment">//继承父类的静态方法</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-title function_">eat</span>(); <span class="hljs-comment">//All animals eat food.</span><br></code></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>ES6 与 ES5 在类继承上对于父类的静态方法处理有很大不同。</p><p>是时候深入底层，走进原型链，探探JavaScript底下的世界。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 类</title>
    <link href="/learn-javascript-class/"/>
    <url>/learn-javascript-class/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近项目中用到了类的概念，其实更早的时候已经接触到了，现在捡起来过一遍，还不晚</p></blockquote><h1 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>ES5 可以通过构造函数进行类的实现。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">//实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; <span class="hljs-comment">//实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//实例方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数实际就是一个普通函数，但我们可以通过 new 关键词进行实例化。在构造函数中声明实例属性和方法，实例上就能读取调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">//实例化</span><br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">//实例化</span><br><br><span class="hljs-comment">//读取实例属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>); <span class="hljs-comment">//张三 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">age</span>); <span class="hljs-comment">//20</span><br><span class="hljs-comment">//调用实例方法</span><br>person1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//张三 is running</span><br>person2.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//李四 is running</span><br></code></pre></td></tr></table></figure><h2 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h2><p>可以在类上添加静态属性和方法，我们能通过类名访问到它们。实例对象不能直接调用类的静态属性方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property">words</span> = <span class="hljs-string">&#x27;I am a person&#x27;</span>; <span class="hljs-comment">//类上添加静态属性</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Person saying: \&quot;<span class="hljs-subst">$&#123;Person.words&#125;</span>\&quot;`</span>); <br>&#125;<br><br><span class="hljs-comment">//在类上读取静态属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">words</span>); <span class="hljs-comment">//Person say: I am a person</span><br><span class="hljs-comment">//在类上调用静态方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">say</span>(); <span class="hljs-comment">//Person saying: &quot;I am a person&quot;</span><br><br><span class="hljs-comment">//不可在实例上读取静态属性 </span><br><span class="hljs-comment">//console.log(person1.words); //undefined</span><br><span class="hljs-comment">//不可在实例上调用静态方法 </span><br><span class="hljs-comment">//person1.say(); //TypeError: person1.say is not a function</span><br></code></pre></td></tr></table></figure><h2 id="原型属性和方法"><a href="#原型属性和方法" class="headerlink" title="原型属性和方法"></a>原型属性和方法</h2><p>可以在类上添加原型属性和方法，我们能通过实例对象访问它们。类不能直接调用原型属性方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">weight</span> = <span class="hljs-number">60</span>; <span class="hljs-comment">//类上添加原型属性</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lostWeight</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加原型方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span>--;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>\&#x27;s weight is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.weight&#125;</span> now!`</span>);<br>&#125;<br><br><span class="hljs-comment">//在实例上读取原型属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">weight</span>); <span class="hljs-comment">//60</span><br><span class="hljs-comment">//在实例上调用原型方法</span><br>person1.<span class="hljs-title function_">lostWeight</span>(); <span class="hljs-comment">//张三 is saying</span><br><br><span class="hljs-comment">//不可在类上读取原型属性 </span><br><span class="hljs-comment">//console.log(Person.weight); //undefined</span><br><span class="hljs-comment">//不可在类上调用原型方法</span><br><span class="hljs-comment">//Person.lostWeight(); //TypeError: Person.lostWeight is not a function</span><br></code></pre></td></tr></table></figure><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>在 ES6 中，类由 class 关键词实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123; <span class="hljs-comment">//实例属性创建</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//实例方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; makes a noise.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>);<br>  &#125;<br>  <span class="hljs-keyword">static</span> words = <span class="hljs-string">&#x27;All animals eat food.&#x27;</span>; <span class="hljs-comment">//静态属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法与 ES5 无异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//调用静态方法</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">eat</span>(); <span class="hljs-comment">//All animals eat food.</span><br><br><span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;Teddy&#x27;</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//实例化</span><br><span class="hljs-comment">//调用实例方法</span><br>dog1.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">//Teddy makes a noise.</span><br></code></pre></td></tr></table></figure><h2 id="静态属性和方法-1"><a href="#静态属性和方法-1" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h2><p>与 ES5 无异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//类上添加静态方法</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property">sleep</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;All animals sleep.&#x27;</span>);<br>&#125;<br><span class="hljs-comment">//在类上调用静态方法</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">sleep</span>(); <span class="hljs-comment">//All animals sleep.</span><br></code></pre></td></tr></table></figure><h2 id="原型属性和方法-1"><a href="#原型属性和方法-1" class="headerlink" title="原型属性和方法"></a>原型属性和方法</h2><p>与 ES5 无异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//类上添加原型方法</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running.&#x27;</span>);<br>&#125;<br><span class="hljs-comment">//在实例上调用原型方法</span><br>dog1.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//Teddy is running.</span><br></code></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>静态属性和方法服务于类本身，原型函数在类上添加但服务于实例。ES6 的 class 关键词是 ES5 构造函数的语法糖，创建有别使用无异。要搞明白后面类的继承还得从构造函数入手。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC Hackergame 2021 Writeup</title>
    <link href="/USTC-Hackergame-2021-Writeup/"/>
    <url>/USTC-Hackergame-2021-Writeup/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>惭愧，大三了才发现这类比赛，第一次参加很激动。这该死的浓厚的来自互联网深处传来的精神魅力深深吸引住了我，虽然参与这竞赛并不能拿奖，但当挖出埋藏的宝藏（flag）时，视野的拓宽、精神的成就和肉体的疲惫交织在一起是真的愉悦。</p><h1 id="解题记录"><a href="#解题记录" class="headerlink" title="解题记录"></a>解题记录</h1><p>这里只记录了一些有意思的题目。</p><h2 id="FLAG-助力大红包"><a href="#FLAG-助力大红包" class="headerlink" title="FLAG 助力大红包"></a>FLAG 助力大红包</h2><blockquote><p>“听说没？【大砍刀】平台又双叒做活动啦！参与活动就送 0.5 个 flag 呢，攒满 1 个 flag 即可免费提取！”</p><p>“还有这么好的事情？我也要参加！”</p><p>“快点吧！我已经拿到 flag 了呢！再不参加 flag 就要发完了呢。”</p><p>“那怎么才能参加呢？”</p><p>“这还不简单！点击下面的链接就行”</p></blockquote><p><img src="/../post-images/1635577589169.png" alt="题目"></p><p>题面来看着实有趣，下面是助力的规则。</p><blockquote><p>活动规则:</p><ol><li>用户在本活动中可以通过邀请好友助力的方式获得 flag 提现机会。收集满 1 个 flag ，即可提取 1 个 flag。</li></ol><p>…</p><ol start="4"><li>每个用户只能够助力一次。为了建设世界一流大砍刀平台，活动要求位于同一 &#x2F;8 网段的用户将会被视为同一个用户。（比如 IP 地址为 202.38.64.1 和 202.39.64.1 将被视为同一用户。）达到助力次数上线后，将无法再帮助好友助力。我们使用<strong>前后端方式</strong>检查用户的 IP 。</li></ol></blockquote><p><img src="/../post-images/1635577645433.png" alt="手动助力"></p><p>试着给自己手动助力一下，加了0.0038836个flag，又仔细看了下题目，同一 &#x2F;8 网段会被视为同一用户，意味着你另外要找全世界127个不同的网段的人帮你，找代理池是个好办法但作为白嫖党当然是不可能的事。</p><p><img src="/../post-images/1635577690422.png" alt="助力失败"></p><p>然后打开了助力页面，看了下请求头，POST地址是助力链接，携带了一个表单，这个ip是从第三方获取到的。手动改一下POST试试。</p><p><img src="/../post-images/1635577715303.png" alt="F12"></p><p><img src="/../post-images/1635577739318.png" alt="ops"><br>很好，还真是前后端检查ip。找了一下还真有伪造ip地址请求的头参数：X-Forwarded-For，然后写了个小脚本。</p><p><img src="/../post-images/1635577778509.png" alt="nice"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;request&#x27;</span>);<br><span class="hljs-keyword">var</span> p = <span class="hljs-regexp">/(?&lt;=alert\&quot;&gt;\n\s+)(.)*/</span><br><span class="hljs-keyword">var</span> uuid = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">options</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-keyword">let</span> ip = <span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>.8.8.8`</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">`http://202.38.93.111:10888/invite/c1b1ff6b-494b-4f3d-8fa7-4150273f4dce`</span>,<br>        <span class="hljs-string">&#x27;headers&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;x-forwarded-for&#x27;</span>: ip,<br>        &#125;,<br>        <span class="hljs-attr">formData</span>: &#123;<br>            ip<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> ip = <span class="hljs-title function_">options</span>(i)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ip);<br>    <span class="hljs-title function_">request</span>(ip, <span class="hljs-keyword">function</span> (<span class="hljs-params">error, response</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">exec</span>(response.<span class="hljs-property">body</span>)[<span class="hljs-number">0</span>]);<br>    &#125;);<br>    i++<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>跑完发现，必须要256个助力，0和255是保留网段，看来出题人已经指定了唯一解法。</p><h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><blockquote><p>共享单车只剩下一辆，走近一看，果然是一辆二维码被坏人涂掉一大块的车，谁也骑不走。</p><blockquote><p>我今天还非就要把这个辆车骑走。</p></blockquote><p>于是你开始研究起来这个二维码。</p></blockquote><p><img src="/../post-images/1635578017018.bmp" alt="qrbefore"></p><p>仔细数了下像素格子，二维码小格边长11像素，马赛克格子边长23像素，这意味着一个马赛克下面一定会完全或部分涵盖9个二维码小格，马赛克色值是所有23X23&#x3D;529个像素色值的均值并<strong>向下取整</strong>。</p><p>因为原二维码图片的像素非黑即白，我们知道了马赛克的色值，就能求得529个像素内白色像素的个数范围（向下取整造成的范围）。一个马赛克可以根据二维码小格边界分为九个区域，因为一个二维码小格内的像素色值是相同的，所以我们可以让九个格子随意组合（1到9个、每个区域只能用一次），挑出唯一在白色像素范围内的组合，那他们就是白格子（二维码格子），其余是黑格子。当然事情并不会那么顺利，如果组合大于一组，我们还可以根据已知的区域缩小范围或者求他们的交集与先并后非集得出唯一组合或确定的某个区域。</p><p>理论是有了，实现上我又写了个脚本，但是效率太低了，不能实现自动化去马赛克，只能拉来一个免费劳动力帮我整（惨）。代码打包已经传到了npm上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo npm i -g qrfix <span class="hljs-comment">#全局安装</span><br>qrfix 1 2 30 40 50 <span class="hljs-comment">#前两位是第一区域的像素宽高 从第三位开始依次往右填入马赛克色值</span><br></code></pre></td></tr></table></figure><p><img src="/../post-images/1635578155428.png" alt="qrfinal"></p><p>遗憾的是，直到最后我们还是没能解出来，因为区域区域的相同会造成多组合产生，时间不够导致不难尝试所有可能的组合。如果控制算法做好，能直接生成所有组合的图像，这题不难。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><img src="/../post-images/1635577508835.png" alt="final score"></p><p>1400分，排名240，不错，第一次见识到了差距。</p><p>但从业余无线电字母解释法到特殊的GraphQL数据库设计，再从逆马赛克算法设计到全局npm指令包制作，短短一周我看到接触到了太多大开脑洞的优秀的可能再也不会接触的思想逻辑与技能知识。无论结果如何，这一周可以说是荒废又充实的。CTF真是太棒了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习小结</title>
    <link href="/Iot-Exp-find-the-way/"/>
    <url>/Iot-Exp-find-the-way/</url>
    
    <content type="html"><![CDATA[<p>啃了几天的中文网络垃圾，终于算搞明白了一点点。</p><ul><li><p>根文件系统与busybox、yaffs的关系</p><p>根文件系统的制作需要用到busybox和yaffs。</p><ul><li><p>busybox：</p><p>有人将BusyBox比喻成Linux工具的瑞士军刀，简单的说busybox就是Linux的一个大的工具集，包括了Linux中的大部分命令和工具。</p></li><li><p>yaffs：</p><p>YAFFS文件系统是专门为Nand Flash设计的文件系统，YAFFS目前有yaffs、yaffs2两个版本，yafffs由mkyaffsimage生成，而yaffs2由mkyaffs2image生成，两者的步骤是一样的。</p></li></ul><p>busybox会在根目录（此处是相对于根文件系统的说法，对于开发机就只是个普通目录，下同）中释放必要的Linux命令文件和工具，yaffs则是将根目录打包成根文件系统镜像。</p></li><li><p>uboot与内核与根文件系统的关系</p><p>机器启动首先执行uboot，uboot调起内核，内核挂载根文件系统，再去挂载其他文件系统，挂载完成后才会启动应用程序。</p></li></ul><p>至此才明白了整个流程，内核裁剪、根文件系统与uboot制作的界限逐渐清晰，弄清大局，对于后面的实践就有了信心。</p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 MongoDB Atlas 与 Heroku 架设 Free 的后台服务</title>
    <link href="/freedom-service/"/>
    <url>/freedom-service/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Free：自由、开源、免费！白嫖！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MongoDB Atlas 是 MongoDB 官方提供的线上数据库服务，免费的 M0 Sandbox 档提供 512MB 的容量，有谷歌台湾和微软香港节点可选。</p><p>Heroku 是一个云计算平台，注册用户每个月有550小时的免费计算资源，如果验证了新银行卡还能再加450小时和域名绑定。30分钟不活动就会进入睡眠状态，有新需求的时候就会自动重启。有很多语言环境可选，这里我们用到的是 nodejs。</p><h1 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h1><p>我写了一个练手的后台项目，详情可以见后面发的文章，这次的目的就是把服务架设起来。</p><h2 id="代码调整"><a href="#代码调整" class="headerlink" title="代码调整"></a>代码调整</h2><p>如果是 nodejs 项目，Heroku 启动程序会调用 npm start， 所以确保 package.js 中写好名为 start 的脚本。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//package.js</span><br><span class="hljs-punctuation">&#123;</span><br>  ...<span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  ...<br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span> <span class="hljs-comment">//程序入口</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="链接Github仓库"><a href="#链接Github仓库" class="headerlink" title="链接Github仓库"></a>链接Github仓库</h2><p>Heroku 项目的 Deploy 选项中绑定 Github 仓库，如此当你提交代码后，Heroku 会自动拉取新代码并启用新的代码程序。</p><p><img src="/../post-images/1634999417834.png" alt="Deploy Github"></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>当存在私有代码例如数据库地址与秘钥、第三方 token 时，就可以用环境变量来解决。</p><p>在项目使用私有代码地方填充 <code>process.env.XXX</code>，并在 Heroku 项目的 Setting - Config Vars 选项中填入对应的值，在运行程序前这些环境变量就会被替换。</p><p><img src="/../post-images/1634999401675.png" alt="Config Vars"></p><h2 id="运行！"><a href="#运行！" class="headerlink" title="运行！"></a>运行！</h2><p>可以看到接口服务跑起来了，也能成功对接数据库。当半小时没有访问流量，服务关闭，当我们再次访问接口时，Heroku 重启了程序，服务启动需要约3秒的时间，还是很理想的。<del>（毕竟白嫖的嘛）</del></p><p><img src="/../post-images/1634999351965.png" alt="Heroku Project Log"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>对于类似这种性能要求不高、并发量不大的个人流量统计服务，架设到这种地方确实不失为<del>省钱小妙招</del>有趣的解决方案。希望国内的厂商能为个人提供类似的开源免费计算服务，虽然需要多折腾点，但当你的代码没有金钱的束缚，在广阔的网络中自由奔跑，那想想还真是不错呢。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核裁剪</title>
    <link href="/linux-kernel-clipping/"/>
    <url>/linux-kernel-clipping/</url>
    
    <content type="html"><![CDATA[<blockquote><p>不知道最后能不能成功，但且先记录着，资料太多了，看得好迷茫。</p></blockquote><p>安装虚拟机过程略，系统是<code>Ubuntu 20.04.3 LTS</code>。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>打开终端，下载 linux 源码，这里下载的版本是<code>5.4.0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install linux-source-5.4.0<br></code></pre></td></tr></table></figure><p>下载完后打开下载目录，解压到 <code>/home/USERNAME</code> 。</p><p>值得一提的是这里的 <code>linux-source-5.4.0.tar.bz2</code> 是一个软链接，我们实际上是安装了一个软件包，这个软件包包含了源代码压缩包，并在 <code>/usr/src</code> 下创建了一个软链接，指向的是其同目录同名文件夹下的同名文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src <span class="hljs-comment">#默认下载路径</span><br>tar -jxv -f linux-source-5.4.0.tar.bz2 -C /home/lafish <span class="hljs-comment">#解压</span><br></code></pre></td></tr></table></figure><p>进入解压后的源码目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/lafish/linux-source-5.4.0<br></code></pre></td></tr></table></figure><p>安装交叉编译器，这里的 gcc 版本是 <code>9.3.0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install gcc-arm-linux-gnueabi<br>arm-linux-gnueabi-gcc -v <span class="hljs-comment">#查看版本</span><br></code></pre></td></tr></table></figure><p>编辑源码根目录下的 <code>makefile</code> 文件，检索 <code>ARCH</code> 字段，等于号后面填的是目标平台，可以在 <code>arch/</code> 下找到对应的文件夹名。这里我们不填 <code>arm64</code> 而是 <code>arm</code>，前者会使后面的编译部分出现大量报错，原因未知。同时，在下一行增加 <code>CROSS_COMPILE</code>  填的是交叉编译的工具。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#原</span><br>ARCH                    ?=<br><br><span class="hljs-comment">#改</span><br>ARCH                    ?= arm<br>CROSS_COMPILE   ?= arm-linux-gnueabi- <span class="hljs-comment">#这一条本来没有，需要自己加上</span><br></code></pre></td></tr></table></figure><p>此时输入 <code>make menuconfig</code> 启动配置内核界面会报错，根据提示安装缺少的软件包就行了，我就缺了4个包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install ncurses-dev<br>apt-get install flex<br>apt-get install bison<br>apt-get install libssl-dev<br></code></pre></td></tr></table></figure><h1 id="内核裁剪"><a href="#内核裁剪" class="headerlink" title="内核裁剪"></a>内核裁剪</h1><p>学艺不精，内核配置先略过，下篇再讲。这里从默认配置出发，先走一遍流程。</p><h1 id="生成镜像（误）"><a href="#生成镜像（误）" class="headerlink" title="生成镜像（误）"></a>生成镜像（误）</h1><p>配置完内核选项后，输入下面的命令生成镜像文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make zImage<br></code></pre></td></tr></table></figure><p>出现报错：没有规则可制作目标“debian&#x2F;canonical-certs.pem”</p><p>这是应该是证书出了问题，编辑源码根目录下的 <code>.config</code> 文件，检索 <code>.pem</code>，将两行代码中的值删除即可。</p><p><img src="/../post-images/1634909750962.png" alt=".config检索.pem字段"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#原</span><br><span class="hljs-attr">CONFIG_MODULE_SIG_KEY</span>=<span class="hljs-string">&quot;certs/signing_key.pem&quot;</span><br><span class="hljs-attr">CONFIG_SYSTEM_TRUSTED_KEYRING</span>=y<br><span class="hljs-attr">CONFIG_SYSTEM_TRUSTED_KEYS</span>=<span class="hljs-string">&quot;debian/canonical-certs.pem&quot;</span><br><br><span class="hljs-comment">#改</span><br><span class="hljs-attr">CONFIG_MODULE_SIG_KEY</span>=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">CONFIG_SYSTEM_TRUSTED_KEYRING</span>=y<br><span class="hljs-attr">CONFIG_SYSTEM_TRUSTED_KEYS</span>=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>再次生成，再报错：can’t open file “block&#x2F;Kconfig”</p><p>看来是文件出了点问题，之前好奇动了很多东西，网上的笔记也看得很杂，改动也挺多的，下面重新解压代码重新搞。</p><h1 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h1><p>有了之前的经历，例如源码下载、环境搭建等步骤就不用重新弄了。</p><p>重新将代码解压到合适位置，重新修改 <code>makefile</code> 与 <code>.config</code> 文件。再次运行生成指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make zImage<br></code></pre></td></tr></table></figure><p>这次一切正常，但编译的速度有点慢了，可以加上 <code>-j</code> 参数开启多核编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make zImage -j12 <span class="hljs-comment">#后面的数字代表CPU核心数</span><br></code></pre></td></tr></table></figure><p>看这喂饱的CPU，针不戳。大概7分钟就生成好了，如果不加参数可能是12倍之多了。</p><p><img src="/../post-images/1634909862236.png" alt="喂饱的CPU"></p><p><img src="/../post-images/1634909823235.png" alt="镜像生成完毕"></p><p>生成镜像的路径在 <code>arch/arm/boot/</code>，路径与文件都与师兄师姐们的笔记不一样，应该是代码版本不同导致的，<code>zimage</code> 是 <code>image</code> 压缩后的文件，即便按照默认配置生成，这也是小到出乎我意料。</p><p><img src="/../post-images/1634909883141.png" alt="生成的文件"></p><h1 id="总结与问题"><a href="#总结与问题" class="headerlink" title="总结与问题"></a>总结与问题</h1><p>从<a href="https://www.kernel.org/doc/html/">linux官方文档库</a>中可以看到，最新linux源代码版本是5.15，apt获取的源码而是19年的版本，如果需要从新的源码编译，就得手动下载。之前一条条 <code>apt-get install</code> 安装的工具也一样，很可能是过时的，如果需要安装新的软件，就需要自行去官网下载已编译或甚至编译的软件源码自行安装。这个过程是可以预见的，希望后面的记录会有体验到。</p><p>试过几次裁剪都以失败告终，例如中间提到的文件问题。但默认配置生成的镜像大小至少让我明白了，现阶段裁剪更多的是无用的驱动程序，在编译过程中出现了很多其他品牌的驱动都是无用的。</p><p>最后，提出一些问题，希望后面的篇章能做出解答：</p><ul><li>Uboot相关制作的切入点</li><li>根目录系统制作与Busybox的关系</li><li>arch&#x3D;arm64不可用的原因</li><li>make menuconfig的大致流程</li><li>启动裁剪系统的方法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 Babel</title>
    <link href="/what-is-babel/"/>
    <url>/what-is-babel/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Babel"><a href="#什么是-Babel" class="headerlink" title="什么是 Babel"></a>什么是 Babel</h1><p>Babel 是一个 JavaScript 编译器，是当下前端工程化开发必不可缺的一环，它最主要的作用是语法降级和源码转换。有了 Babel ，写的 ES6 语法能跑在 IE，React 优雅的 JSX 语法开发才得以实现。</p><p>使用 Vue &#x2F; React 等框架的脚手架生成项目，无一例外集成了 Babel，你可以在项目目录中轻松找到 Babel 的存在。</p><p><img src="/../post-images/1633615964818.png" alt="react项目中的Babal配置"><br><img src="/../post-images/1633615924098.png" alt="vue项目中的Babal配置"></p><p>通常情况下，脚手架作者已经将 Babel 配置妥当，无需二次调试。</p><h1 id="让我们试试"><a href="#让我们试试" class="headerlink" title="让我们试试"></a>让我们试试</h1><h2 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//package.json 新建</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@babel/cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.15.7&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.15.5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.15.6&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@babel/polyfill&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.12.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 <code>npm i</code> 或 <code>yarn insatll</code> 安装好包依赖。</p><h2 id="配置Babel"><a href="#配置Babel" class="headerlink" title="配置Babel"></a>配置Babel</h2><p>常见的方法是将配置写入工程根目录的 <code>babel.config.json</code>（如上图Vue-Cli生成的文件）或 <code>.babelrc.json</code> ，再或者直接写进 <code>package.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//package.json 追加</span><br><span class="hljs-punctuation">&#123;</span><br>  ...<span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;@babel/env&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;chrome&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;60&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;useBuiltIns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;usage&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.6.5&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>在这里我们指定 <code>&quot;presets&quot;</code> 的第一项为 <code>@babel/env</code>，这是上文安装好的 <code>@babel/preset-env</code> 的缩写，是官方提供的预设，提供了 ES2015+ 的语法转换。在 Vue-Cli 中，该项为 <code>@vue/cli-plugin-babel/preset</code>，由 Vue-Cli 作者开发。</p></li><li><p><code>&quot;presets&quot;</code> 的第二项是该预设的参数，<code>@babel/env</code> 规定当无传参时，默认转换至 ES5 语法兼容。</p><ul><li>此处 <code>&quot;targets&quot;</code> 指定了代码最低兼容的环境是 chrome v60</li><li><code>&quot;useBuiltIns&quot;: &quot;usage&quot;</code> 导入了作为依赖的<code>@babel/polyfill</code>，其为 ES6+ 的语法降级提供了替换代码</li><li><code>corejs</code> 指定了babel核心 <code>@babel/core</code> 的具体版本</li></ul></li></ul><h2 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h2><p>配置好 Babel 后，让我们研究下怎么启动它。</p><p>作为开发依赖的 <code>@babel/cli</code> 提供了内部指令，使用 <code>node_modules/.bin/babel</code> 我们就可以启动 Babel 了，当然 node 为了内部模块的方便使用，增加了 npx 命令，你还可以这样调用它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># npx babel =&gt; node_modules/.bin/babel</span><br>npx babel src --out-dir dist<br></code></pre></td></tr></table></figure><ul><li><p>第一项参数表示输入的源代码目标文件夹或文件，在这里我们指定编译 <code>src/</code> 下所有的文件</p></li><li><p>第二项 <code>--out-dir</code> 可选参数表示编译后输出的文件目录，在这里我们指定编译输出至 <code>dist/</code> 文件夹中</p></li></ul><p>现在让我们在 <code>src/</code> 中创建一个 <code>app.js</code>，输入一些 ES6+ 代码，保存文件，输入脚本指令，Babel 就会自动编译并保存在 <code>dist/</code> 了。</p><p><img src="/../post-images/1633616072839.png" alt="第一次手动编译"></p><p>显示成功了，<code>dist/app.js</code> 也填充了编译后的代码，但我们发现并没有什么变化。这是因为我们在 <code>package.json</code> 中配置的转换目标是 chrome v60，它已经支持了 class 和箭头函数语法。想看点不一样的，让我们把配置拉低”亿“点。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//package.json 新增</span><br><span class="hljs-punctuation">&#123;</span><br>  ...<span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;@babel/env&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;chrome&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;60&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;ie&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;useBuiltIns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;usage&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.6.5&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这次我们增加了臭名昭著的 IE 浏览器，版本是 2013 年最新推出的 IE11，它仍将持续服役至 2022 年。</p><h1 id="加点料"><a href="#加点料" class="headerlink" title="加点料"></a>加点料</h1><p>暂停一下，带你认识一个好用的工具——nodemon。</p><p>nodemon 的作用很简单，监听文件变化，并执行一些命令。使用 <code>npm i nodemon -D</code>或<code>yarn add nodemon -D</code> 安装，这里 <code>-D</code> 指将它作为开发依赖安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nodemon --watch src --<span class="hljs-built_in">exec</span> npx babel src --out-dir dist<br></code></pre></td></tr></table></figure><ul><li><code>--watch</code> 指监听的文件或文件夹，这里我们要监听 <code>src/</code> 中的文件</li><li><code>--exec</code> 指文件变动后运行的指令，这里就填入上文的指令</li></ul><p>将 nodemon 跑起来，现在当我们在 <code>src/</code> 中保存文件时，nodemon 就会触发指令，Babel 也会自动转换代码到 <code>dist/</code> 中了。</p><p><img src="/../post-images/1633616089808.gif" alt="保存自动编译"></p><p>有内味了，就像是 Vue 和 React 一样。看编译后的代码可以发现，Babel 将箭头函数直接转换成了普通函数，class 语法则是引入了 Babel 的 <code>_createClass</code> 辅助函数，以ES5语法实现了 ES6 的功能。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这次测试，没有深入剖析 Babel 的原理，只是简单上手实现了基础的保存自动转换功能，但我们仍能从中窥见前端底层技术的魅力，新的标准未有确定，但我们依然能在现有的框架下实现新东西，正是这样的超前应用推动了前端不断发展、愈发繁华。</p><p>实际项目中，我们很少会去调试 Babel，因为各种脚手架已经为我们铺垫好了道路。这篇文章希望能予你些启发，或许不会再有更多的调试，但它们确实为前端工程化发展打下了坚实的基础。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麻了</title>
    <link href="/ma-le/"/>
    <url>/ma-le/</url>
    
    <content type="html"><![CDATA[<p>一等奖学金差2，三好标兵绩点差0.01，奈人更卷，直接白给，麻了<br>只恨自己不加劲，只剩明年努努力，只望体测别卡死，枯了</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第十二题</title>
    <link href="/sqsf-12/"/>
    <url>/sqsf-12/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标<code> l</code> 和 <code>r</code>（l &lt; r）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><blockquote><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span><br>输出：3<br>解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。<br>尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 <br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span><br>输出：1<br>解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。<br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCode-674</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onst findLengthOfLCIS = <span class="hljs-function"><span class="hljs-params">nums</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新最大长度</span><br>        res = dp[i] &gt; res ? dp[i] : res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又<sup>6</sup>是一道动态规划题，也能用贪心解决，是道水题，这里主要展现动态规划思想，仍是三部曲：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p><code>dp[i]</code>：从0到下标为i的子数组中，最后一个连续递增序列的长度。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p>若<code>nums[i] &gt; nums[i - 1]</code>，则<code>dp[i] = dp[i - 1] + 1</code>。</p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[0] = 1</code></p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>用贪心会更好，但结合动态规划会有更好的理解。dp的定义需要巧妙的构思，需要抓住<code>dp[i]</code>与<code>i</code>的关系，这里应该有想法出来但我写不出文字。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第十一题</title>
    <link href="/sqsf-11/"/>
    <url>/sqsf-11/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCode-300</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">lengthOfLIS</span> = (<span class="hljs-params">nums</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(result, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又<sup>5</sup>是一道动态规划题，是子序列系列问题的入门题，仍是抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p><code>dp[i]</code>：考虑前 <em>i</em> 个元素，以第 <em>i</em> 个数字结尾的最长上升子序列的长度。</p><p>需要把第 <em>i</em> 个元素考虑进去，即假设<code>nums=[1,2,3]</code>，<code>dp[2]</code>表示从下标0到下标2的最长上升子序列，很显然等于3。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p><code>dp[i] = max(dp[j])+1</code>，其中<code>0 ≤ j &lt; i</code>且<code>num[j] &lt; num[i]</code></p><p>参考力扣<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">官方解析</a>中的动画演示能更好理解。</p><p>需要二层循环，外层假设<code>nums[i]</code>为子序列的最后一个元素，内层假设<code>nums[j]</code>为子序列的第一个元素，结合<code>dp[i]</code>的定义，就能得到最长度。</p><p>时间复杂度是O(n<sup>2</sup>)。</p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[1] = 1</code></p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>虽然是入门子序列的问题，但对我而言仍是秃头难想得出的，理解答案已经有点难了，还需要不断的记忆相关类型的套路才行。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第十题</title>
    <link href="/sqsf-10/"/>
    <url>/sqsf-10/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCode-53</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sum = num;<br>        &#125;<br>        ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又又又又是一道动态规划题，难度中等，仍是抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p><code>dp[i]</code>：表示以 <code>nums[i]</code> <strong>结尾</strong> 的 <strong>连续</strong> 子数组的最大和。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p>根据状态的定义，由于 <code>nums[i]</code> 一定会被选取，并且以 <code>nums[i]</code> 结尾的连续子数组与以 <code>nums[i - 1]</code> 结尾的连续子数组只相差一个元素 <code>nums[i]</code> 。</p><p>假设数组 <code>nums</code> 的值全都严格大于 00，那么一定有 <code>dp[i] = dp[i - 1] + nums[i]</code>。</p><p>可是 <code>dp[i - 1]</code> 有可能是负数，于是分类讨论：</p><ul><li>如果 <code>dp[i - 1] &gt; 0</code>，那么可以把 <code>nums[i]</code> 直接接在 <code>dp[i - 1]</code> 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 <code>dp[i - 1] &lt;= 0</code>，那么 <code>nums[i]</code> 加上前面的数 <code>dp[i - 1]</code> 以后值不会变大。于是 <code>dp[i]</code> 「另起炉灶」，此时单独的一个 <code>nums[i]</code> 的值，就是 <code>dp[i]</code>。</li></ul><p>综上可以推导出<code>dp[i]=max&#123;nums[i] , dp[i−1]+nums[i]&#125;</code>。</p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[0] = nums[0]</code></p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>又是一道凭空想不出解的动态规划题，还是得多刷几道才行。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第九题</title>
    <link href="/sqsf-9/"/>
    <url>/sqsf-9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCode-72</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">minDistance</span> = (<span class="hljs-params">word1, word2</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title class_">Array</span>(word1.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>), <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(word2.<span class="hljs-property">length</span>+<span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-property">length</span>; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i; <br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-property">length</span>; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span>(word1[i-<span class="hljs-number">1</span>] === word2[j-<span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-property">length</span>][word2.<span class="hljs-property">length</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又又又是一道动态规划题，但比较难，仍是抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p><code>dp[i][j]</code> 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为<code>dp[i][j]</code>。</p><p>有点难想象到，但逻辑是寻的通的。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])<br>    不操作<br><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] != word2[j - <span class="hljs-number">1</span>])<br>    增<br>    删<br>    换<br></code></pre></td></tr></table></figure><p><code>word1[i - 1] == word2[j - 1]</code>时，即当前字符是对应相同的，所以不需要变动，<code>dp[i][j] = dp[i - 1][j - 1]</code>，当前格子的dp等于左上角的dp，这里需要回到dp的定义，会有点难理解。可以这样看，当前字符对比相同时，需要跳过当前而对比下一个字符，word1和word2对比下一个字符就相当于<code>dp[i + 1][j + 1]</code>，因为上一个字符相同，所以不需要操作，所以编辑距离就等于<code>dp[i][j]</code>，由于我们需要的是下一个字符的推导式，所以可以等价于<code>dp[i][j] = dp[i - 1][j - 1]</code>（全部变量自减1）。</p><p><code>word1[i - 1] != word2[j - 1]</code>时，即当前字符是对应不同的，所以需要变动，可能是增删换其中一个。增相当于word1++，可以在矩阵中看做往下一格。增相当于word2++，可以在矩阵中看做往右一格。换相当于word1++与word2++，可以在矩阵中看做往右下一格。无论怎么操作，编辑距离都要加1。对于如何操作，自然选择最小的编辑距离。所以有<code>dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1</code></p><p><img src="https://i.loli.net/2021/08/18/KNO2FjRig5vtBrG.png"></p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[i][0] = i</code>、<code>dp[0][j] = j</code>。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>dp的定义非常重要，如何定义dp仍需不断的练习。此题动态规划非常巧妙，可以多看几遍。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第八题</title>
    <link href="/sqsf-8/"/>
    <url>/sqsf-8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"></p><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCodeHOT100-64</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minPathSum3 = <span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) &#123;<br>    <span class="hljs-keyword">const</span> m = grid.<span class="hljs-property">length</span>, n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span><br><br>    <span class="hljs-comment">// 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和</span><br>    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>))<br><br>    <span class="hljs-comment">// 状态初始化</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">// 状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m ; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j != <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = grid[i][j] + dp[i][j - <span class="hljs-number">1</span>]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = grid[i][j] + dp[i - <span class="hljs-number">1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j != <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = grid[i][j] + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又又是一道动态规划题，这次是带权规划，继续抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p>定义 <code>dp[i][j]</code> 的含义为：从左上角走到 (<em>i</em>,<em>j</em>) 的最小路径和。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p>到达(i,j)有两种方式：</p><ul><li><p>一种是从上往下</p></li><li><p>一种是从左往右</p></li></ul><p>每一次只选择上或左最小的路径和，所以有 <code>dp[i，j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]</code>。二维数组grid是权值矩阵。</p><p><img src="https://i.loli.net/2021/08/18/THA2Ue8KwXykvls.png"></p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[0][0]=grid[0][0]</code>、<code>dp[0][j]=dp[0][j−1]+grid[0][j]</code>、<code>dp[i][0]=dp[i−1][0]+grid[i][0]</code>。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>带权值的动态规划是很常见的题型，需要使用<code>Min()</code>或<code>Max()</code>等判断式做最佳的选择。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第七题</title>
    <link href="/sqsf-7/"/>
    <url>/sqsf-7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCodeHOT100-62</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) &#123;<br>    <span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        f[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这又是一道动态规划题，继续抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p>定义 <code>dp[i][j]</code> 的含义为：从左上角走到 (<em>i</em>,<em>j</em>) 的路径数量。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p>到达(i,j)有两种方式：</p><ul><li><p>一种是从上往下</p></li><li><p>一种是从左往右</p></li></ul><p>算所有可能的路径，所以有 <code>dp[i，j] = dp[i-1][j] + dp[i][j-1]</code>。</p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p><code>dp[0][0]</code>、<code>dp[0][j]</code>、<code>dp[i][0]</code>都为1。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>这是一道很基础的二维动态规划题，与一维的思想是相似的，二维动态规划是在寻找<code>dp[i][j]</code>与<code>dp[i-1][j]</code>、<code>dp[i][j-1]</code>、<code>dp[i-1][j-1]</code>的关系。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客回迁Github Pages</title>
    <link href="/back-to-github-pages/"/>
    <url>/back-to-github-pages/</url>
    
    <content type="html"><![CDATA[<p>不是什么大事，但还是记录一下吧。<br>就在今天，Coding的旧版静态网站部署已经停止了，拖了这么久终于要开始收费啦。<br>Coding文档计算给出的价格在一个月一毛钱左右，不算贵。<del>但我又算了一下，10年的博客要花我20块大洋，比较家境贫寒，还是能省则省罢。</del><br>对比Coding的收费服务，GithubPages提供的服务好像更有优势，首先是免费，其次是节点多，<del>当然最重要的还是免费</del>。对于没有备案的小站点，Coding只提供香港节点，静态资源存储和CDN还要分开收费，<del>虽然没什么人看</del>。<br>好吧，还是承认Coding的服务是值得的，但就是懒得折腾了，GithubPages的配置一直在，改个DNS就好，未来还指不定变主意呢。<br><del>总的说，白嫖使我快乐。</del></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第六题</title>
    <link href="/sqsf-6/"/>
    <url>/sqsf-6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>来源：知乎</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">( <span class="hljs-type">int</span> n )</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-comment">// 先创建一个数组来保存历史数据</span><br>    <span class="hljs-type">int</span>[] dp = new <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 给出初始值</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//无意义</span><br>  dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 通过关系式来计算出 dp[n]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-comment">// 把最终结果返回</span><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>这是一道动态规划题，做此类题型必须抓住三个要点：</p><h2 id="定义数组元素的含义"><a href="#定义数组元素的含义" class="headerlink" title="定义数组元素的含义"></a>定义数组元素的含义</h2><p>定义 dp[i] 的含义为：<strong>跳上一个 i 级的台阶总共有 dp[i] 种跳法</strong>。</p><h2 id="找出数组元素间的关系式"><a href="#找出数组元素间的关系式" class="headerlink" title="找出数组元素间的关系式"></a>找出数组元素间的关系式</h2><p>由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式：</p><ul><li><p>一种是从第 n-1 级跳上来</p></li><li><p>一种是从第 n-2 级跳上来</p></li></ul><p>由于我们是要算所有可能的跳法的，所以有 <code>dp[n] = dp[n-1] + dp[n-2]</code>。</p><h2 id="找出初始条件"><a href="#找出初始条件" class="headerlink" title="找出初始条件"></a>找出初始条件</h2><p>不能通过公式得出的dp[i]值都应该提前给出。</p><p>此题关系式中存在n-1与n-2，并且dp[0]是无意义的，所以应该提前给出n&#x3D;1与n&#x3D;2的初始值。通过简单计算可知dp[1]&#x3D;1、dp[2]&#x3D;2。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>这是一道很基础的一维动态规划题，用以入门动态规划算法是不错的。做动态规划算法有三大要点：dp数组定义、关系式和初始条件。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第五题</title>
    <link href="/sqsf-5/"/>
    <url>/sqsf-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCodeHOT100-121</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">prices</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) &#123;<br>    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span> <span class="hljs-comment">// 初始利润设为0</span><br>    <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>] <span class="hljs-comment">// 确定一个股票中的最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(prices[i] &lt; min) &#123;  <span class="hljs-comment">// 遍历时进行最小值赋值</span><br>            min = prices[i]<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i]  - min &gt; profit)&#123; <span class="hljs-comment">// 如果出现比最大利润还要大的就进行重新赋值</span><br>            profit = prices[i]  - min<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>逆向思维，假设现在要卖出，目前卖出价格是确定的，想要获取最大的利润，买入就必须是从开始到目前的最低价。即每遍历一个价格时，不断比对取最小值作为买入价格，并与假设当前价格卖出能获取的利润取最大值。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>类似的股价题型有很多，此题是最基础的。当买卖需要手续费、买入有冻结期、开放多次买卖等需求时，就需要动态规划更复杂的算法思想。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第四题</title>
    <link href="/sqsf-4/"/>
    <url>/sqsf-4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请<strong>不要</strong>使用另一个矩阵来旋转图像。</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1]]</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-string">[[3,1],[4,2]]</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCodeHOT100-48</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = matrix.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 左右翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            [matrix[i][j], matrix[n - i - <span class="hljs-number">1</span>][j]] = [matrix[n - i - <span class="hljs-number">1</span>][j], matrix[i][j]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 矩阵转置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>转置矩阵：将矩阵的行和列调换，也可理解为主对角线翻转。</p><p><img src="https://i.loli.net/2021/08/12/m5GV2qfeK819cDz.png" alt="转置矩阵"></p><p>题目顺时针旋转90°可以看做将矩阵左右翻转+矩阵转置。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>通过左右翻转、上下翻转和矩阵转置，可以实现矩阵的任意旋转。</p><ul><li>顺时针180°：上下翻转+左右翻转</li><li>顺时针270°：上下翻转+矩阵转置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 左右翻转</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>); i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    [matrix[i][j], matrix[n - i - <span class="hljs-number">1</span>][j]] = [matrix[n - i - <span class="hljs-number">1</span>][j], matrix[i][j]];<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 上下翻转</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        [matrix[j][i], matrix[j][n - i - <span class="hljs-number">1</span>]] = [matrix[j][n - i - <span class="hljs-number">1</span>], matrix[j][i]];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 矩阵转置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>    [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第三题</title>
    <link href="/sqsf-3/"/>
    <url>/sqsf-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>输入：s &#x3D; “([)]”<br>输出：false</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>输入：s &#x3D; “{[]}”<br>输出：true</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>来源：LeetCodeHOT100<span class="hljs-number">-20</span><br><br># 题解<br><br>```javascript<br>var isValid = <span class="hljs-built_in">function</span> (s) &#123;<br> <span class="hljs-type">const</span> stack = [];<br> <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>   let c = s[i];<br>   <span class="hljs-keyword">switch</span> (c) &#123; <span class="hljs-comment">//如果是左括号，对应有括号入栈</span><br>     <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>       stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>       stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>       stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>: <span class="hljs-comment">//如果是右括号，栈顶取出并比对</span><br>       <span class="hljs-keyword">if</span> (c !== stack.<span class="hljs-built_in">pop</span>()) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>   &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>; <span class="hljs-comment">//确保没有多余的括号</span><br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>使用栈实现，遍历时直接压入对应的字符，等右括号来了再比对，符合的就出栈，最后检查剩余字符，确保没有左右括号多余的情况。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>使用哈希表会有更简洁的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">const</span> stack = [], <br>        map = &#123;<br>            <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br>            <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br>            <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br>        &#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> s) &#123; <span class="hljs-comment">//遍历s</span><br>        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">in</span> map) &#123; <br>            stack.<span class="hljs-title function_">push</span>(x);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;;<br>        <span class="hljs-keyword">if</span>(map[stack.<span class="hljs-title function_">pop</span>()] !== x) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//此处使用了哈希表</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> !stack.<span class="hljs-property">length</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一道水题，但看完后大为惊讶，原来能这么简单，前次比赛有遇到，想着简单但就是写不出来，看来还是水平不够。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第二题</title>
    <link href="/sqsf-2/"/>
    <url>/sqsf-2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ac&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p>来源：LeetCodeHOT100-5</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-title function_">diff</span>(i, i);<span class="hljs-comment">//奇数回文扩散</span><br>    <span class="hljs-title function_">diff</span>(i, i + <span class="hljs-number">1</span>);<span class="hljs-comment">//偶数回文扩散</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params">m, n</span>) &#123;<br>    <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[m] == s[n]) &#123;<br>      m--;<br>      n++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n - m - <span class="hljs-number">1</span> &gt; res.<span class="hljs-property">length</span>) &#123;<span class="hljs-comment">//保留最长回文子串</span><br>      res = s.<span class="hljs-title function_">slice</span>(m + <span class="hljs-number">1</span>, n);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>中心扩散法：利用回文子串中心对称的特点，每一个字符都视作为中心，往两边扩散。</p><p>偶数子串和奇数子串两种情况都需要考虑。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>这题暴力也能做，但时间复杂度会到$O(n^3)$。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期算法 第一题</title>
    <link href="/sqsf-1/"/>
    <url>/sqsf-1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</p><p>来源：剑指offer 64</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNums = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">var</span> flag = n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += <span class="hljs-title function_">sumNums</span>(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> n;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题析"><a href="#题析" class="headerlink" title="题析"></a>题析</h1><p>与运算 (A &amp;&amp; B) 有以下规则：</p><ul><li><p>从左开始执行</p></li><li><p>如果A执行后为False，则直接返回False.</p></li><li><p>如果A执行后为True，则继续执行B并返回其值</p></li></ul><p>将递归条件判断放在A，然后具体递归放在B执行，通过A来决定B是否可以运行。此题的A是<code>n &gt; 1</code>，B是<code>n += sumNums(n - 1)</code>，B后面紧跟着的<code>&gt; 0</code>是无意义的，只是用来凑足判断式，触发执行B的内容。</p><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>初看题目并没有思路，递归算法也不是很熟练，平时都是能不用就不用的，暴力解决一切。这次刚好撞上只能用递归解法，终于来一了次完整的递归展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*递归展开*/</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params">n = <span class="hljs-number">3</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> &amp;&amp; (n = <span class="hljs-number">3</span> + <span class="hljs-comment">/*3*/</span><br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">n = <span class="hljs-number">2</span></span>) &#123;<br>        <span class="hljs-keyword">var</span> flag = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> &amp;&amp; (n = <span class="hljs-number">2</span> + <span class="hljs-comment">/*1*/</span><br>        <span class="hljs-keyword">function</span> (<span class="hljs-params">n = <span class="hljs-number">1</span></span>) &#123;    <br>            <span class="hljs-keyword">var</span> flag = <span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span> &amp;&amp; (n += <span class="hljs-title function_">sumNums</span>(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span> <span class="hljs-comment">/*不执行*/</span><br>            <span class="hljs-keyword">return</span> n; <span class="hljs-comment">/*1*/</span><br>            &#125;;) &gt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> n; <span class="hljs-comment">/*3*/</span><br>    &#125;;) &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> n; <span class="hljs-comment">/*6*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>结构递归应该从最里层开始看，一步一步往前推，这里的递归条件<code>n&gt;1</code>即<code>n=1</code>时递归开始崩溃，崩溃的第一个（最内层）函数返回值就是输入本身（n&#x3D;1）。递归的思想很巧妙，脑内完整的运行一遍有点困难，所以写递归还是需要套路，需要多加练习。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021的小目标</title>
    <link href="/my2021Goal/"/>
    <url>/my2021Goal/</url>
    
    <content type="html"><![CDATA[<p>一年前给自己定的9个目标的完成了七个，今年继续！</p><blockquote><p>上一年剩下的：</p><ul><li><input disabled="" type="checkbox"> 过英语四级</li><li><input disabled="" type="checkbox"> 做一套Gridea主题</li></ul></blockquote><p>英语四级第一次裸考，只背了两段作文模板，其实还没出成绩，自我感觉是要挂的了。中学吃小学老本，大学吃中学老本，单词没背几个，是该努力下了。对于博客的主题，自认为水平不够，试试今年能不能完成吧。</p><ul><li><input disabled="" type="checkbox"> 拿奖学金（不能挂科不能挂科不能挂科）</li><li><input disabled="" type="checkbox"> 做一个产品（要达到理想的水平）</li><li><input disabled="" type="checkbox"> 减个50斤（身体真的很重要）</li></ul><p>5个小目标，想到再加，期待达成！</p>]]></content>
    
    
    <categories>
      
      <category>小目标</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Electron入门随笔</title>
    <link href="/my-electron/"/>
    <url>/my-electron/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里是写作文苦手，退堂鼓大师，未来秃头码农，图灵新一届的前端小白。翻了翻公众号往期推文，发现前端的师兄师姐们各个身怀绝技，把我肚子里有的写了个遍。这篇推文就给大家介绍一个前端领域很火的小玩具——Electron。</p><p>在近期的图灵招新一轮笔试中，大家想在讲台投影剩余考试时间，这使我催生出用前端做出桌面应用的想法。</p><blockquote><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。–官网</p></blockquote><p>可以说，Electron几乎是前端开发桌面应用的唯一途径，很多大厂都使用 Electron 开发自己的原生应用，微软的Visual Studio Code就是Electron的成功开发案例。</p><p>下面我就从一个倒计时网页入手，借助Electron制作适用于macOS和Windows系统的桌面软件。</p><h1 id="网页准备"><a href="#网页准备" class="headerlink" title="网页准备"></a>网页准备</h1><p>使用Vue框架开发倒计时网页的部分就不献丑了，直接贴build出的代码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/LeUKi/</span>Timer    <br></code></pre></td></tr></table></figure><p><img src="/../post-images/1606962654773.png"></p><p><img src="/../post-images/1606962784505.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Electron官方友好地提供了一个测试demo，在此基础上稍作调整，就可以很轻松地完成转换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/electron/electron-quick-start<br><span class="hljs-built_in">cd</span> electron-quick-start<br>npm install<br></code></pre></td></tr></table></figure><p>在demo项目安装包文件的最后会一并安装Electron，如果下载速度很慢可以提前结束进程，使用<code>cnpm install electron -g </code>加速安装Electron。</p><p>安装完后可以输入<code>electron .</code>测试，如果能弹出demo应用窗口，则代表安装完成。</p><h1 id="调整文件"><a href="#调整文件" class="headerlink" title="调整文件"></a>调整文件</h1><p>我们需要把官方demo的网页演示文件，替换为我们自己的网页。</p><p>删除electron-quick-start文件夹内的<code>index.html</code>和<code>renderer. js</code>，将之前用Vue写好并build出的页面放进去。</p><p><img src="/../post-images/1606962813247.png"></p><p>再次输入<code>electron .</code>测试，如果能弹出倒计时应用窗口，则代表替换成功了。</p><p><img src="/../post-images/1606962823286.png"></p><h1 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h1><p>上述过程的electron相当于一个另类的浏览器，它能让网页脱离系统浏览器，运行在各种系统上。我们希望分发给用户的东西是个完整体，即开即用，无需编译，所以我们还需要打包应用。</p><p>electron-packager是Electron开发常用的打包工具，它可以将Electron项目打包为macOS、Windows和Linux上的可执行文件或者安装文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install electron-packager -g<br></code></pre></td></tr></table></figure><p>安装完后在项目根目录输入<code>electron-packager . --platform=win32</code>即可完成Windows应用的打包，针对macOS平台把<code>win32</code>改为<code>darwin</code>即可。</p><p>在electron-quick-start-darwin-x64和electron-quick-start-win32-x64文件夹中，我们可以找到对应的程序文件，运行效果和使用<code>electron .</code>测试无异。!</p><p><img src="/../post-images/1606962861169.png"></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>很可笑的是，就这么一个简单的网页应用，打包完后两个平台的程序体积都能达到百来兆，而原本的网页文件仅有5.7M。<del>把网页和浏览器安装包放在一起都没这么大 XD</del></p><p><img src="/../post-images/1606962871778.png"></p><p><img src="/../post-images/1606962879534.png"></p><p>总的来说，对于初入前端的老菜鸟，Electron有很大的吸引力，前端可以不用写</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记微信小程序开发踩过的坑</title>
    <link href="/wechat-miniprogram-development-trouble/"/>
    <url>/wechat-miniprogram-development-trouble/</url>
    
    <content type="html"><![CDATA[<h1 id="如何获取用户标识–openid"><a href="#如何获取用户标识–openid" class="headerlink" title="如何获取用户标识–openid"></a>如何获取用户标识–openid</h1><p>刚开始上手项目，就被openid难住了，官方文档中对于openid的获取方式这对于还未接触到云函数的新手实在不友好。说明中提到的“开发者服务器”是个大麻烦，甚至还需要解密code才能获取到需要的数据。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">官方文档：<br>1.调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。<br>2.调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。<br></code></pre></td></tr></table></figure><p>学到后面才知道，使用云函数就能很方便的获取到用户的openid，这足矣应付类似团队实验室打卡的简单小程序。有云函数加持，简单的小程序开发就不需要大动干戈使用服务器，同时免费云函数套餐质量也出奇的高，这样看来微信对于小型开发者还是很友好的。</p><h1 id="如何在小程序中使用npm"><a href="#如何在小程序中使用npm" class="headerlink" title="如何在小程序中使用npm"></a>如何在小程序中使用npm</h1><p>对于不想使用微信简陋原生组件的开发者，官方的开发软件也很友好的提供了npm 支持。在第一步执行<code>npm i</code>指令时有个小坑，对于新手稍不注意就会敲错地方。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">官方文档：<br>1. 安装 npm 包<br>在小程序 package.json 所在的目录中执行命令安装 npm 包<br></code></pre></td></tr></table></figure><p>小程序开发的“项目文件夹”和“小程序主目录”并不是一回事，默认的小程序主目录是项目文件夹下的<code>miniprogram/</code>文件夹，同级的还有云函数文件夹<code>cloudfunctions/</code>。当我们想在小程序中引入第三方的包时，需要先<code>cd miniprogram/ </code>再<code>npm i</code>。新手如果在项目文件夹中执行指令，就会出现npm构建失败的提示。</p><h1 id="如何上手云函数本地环境调试"><a href="#如何上手云函数本地环境调试" class="headerlink" title="如何上手云函数本地环境调试"></a>如何上手云函数本地环境调试</h1><p>云函数和小程序端的js代码一样，都是运行在node环境中。小程序端的运行环境不一，过多的数据库操作放在小程序中会造成不同设备体验上的差异。<br>云函数生来就是解决这些问题的，但对于云函数再小的代码修改都需要上传部署才能测试，一个在本地模拟云端运行的云函数调试就显得很有必要。前面说过，云函数是基于node环境运行的，所以调试本地的云函数就需要先安装好各种包（特别是<code>wx-server-sdk</code>）。<br>对本地目录中的云函数文件夹右键，选择“在外部终端打开”，执行<code>npm i</code>就能在本地安装好调试云函数的所有环境。</p><h1 id="如何在云函数中获取正确的时间"><a href="#如何在云函数中获取正确的时间" class="headerlink" title="如何在云函数中获取正确的时间"></a>如何在云函数中获取正确的时间</h1><p>如果在云函数中使用到了<code>Date()</code>，就特别需要注意，运行云函数的实例默认的环境时区是UTC+0，并不是中国时间，所以根据官方文档的要求，我们需要配置函数的环境变量，设置 TZ 为 Asia&#x2F;Shanghai。<br>这个环境的设置在“云开发控制台”-“云函数”-对应云函数的“版本管理”-“配置”，在弹出的窗口中设置环境变量的Key为“TZ”，Value为“Asia&#x2F;Shanghai”即可。<br>有个取巧的方法，在小程序调用的时候就传入一个Date()。需要注意的是在云函数端需要用<code>new Date(event.time)</code>取出，在这里不能省略new，否则取出的值将会是字符串。</p><h1 id="小程序端和云函数端在get数据库时的写法差异"><a href="#小程序端和云函数端在get数据库时的写法差异" class="headerlink" title="小程序端和云函数端在get数据库时的写法差异"></a>小程序端和云函数端在get数据库时的写法差异</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">小程序端：<br>db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">where</span>(&#123;xxx&#125;).<span class="hljs-title function_">get</span>(&#123;<br>    <span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;<br>&#125;)<br>小程序端、云函数端：<br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">where</span>(&#123;xxx&#125;).<span class="hljs-title function_">get</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br></code></pre></td></tr></table></figure><p>对于云函数端，get的参数不能放任何东西，需要用await，把返回的结果对象赋值给另一个变量才可使用，否则会报错，并且这个错误似乎没有人指出是什么造成的，当时反复测试对比才发现不能这样写，文档中似乎没有说明。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现Gridea同步Coding与Github两地仓库</title>
    <link href="/JXuv5fwl9/"/>
    <url>/JXuv5fwl9/</url>
    
    <content type="html"><![CDATA[<p>Gridea有一点不好，就是不能同时推送到两个仓库。下面这个方法可以实现Coding与Github两地仓库的同步，解决不能异仓备份博客的问题。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.登录coding账户<br>2.进入Coding博客仓库-持续集成-构建计划-新建-简易模板<br>（<a href="https://你的用户名.coding.net/p/%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93%E5%90%8D/ci/job/create/simple">https:&#x2F;&#x2F;你的用户名.coding.net&#x2F;p&#x2F;博客仓库名&#x2F;ci&#x2F;job&#x2F;create&#x2F;simple</a>）<br><img src="/../post-images/20200621104214.png"><br>3.随意起名，选择仓库，创建构建计划<br>4.进入创建的计划-流程配置-文本编辑器<br>5.删除全部代码，粘贴下面的代码后保存</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua">pipeline &#123;<br>  agent any<br>  stages &#123;<br>    stage(<span class="hljs-string">&#x27;检出&#x27;</span>) &#123;<br>      steps &#123;<br>        checkout([<br>          $class: <span class="hljs-string">&#x27;GitSCM&#x27;</span>,<br>          branches: <span class="hljs-string">[[name: env.GIT_BUILD_REF]]</span>,<br>          userRemoteConfigs: <span class="hljs-string">[[url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID]]</span><br>        ])<br>      &#125;<br>    &#125;<br>    stage(<span class="hljs-string">&#x27;推送部署&#x27;</span>) &#123;<br>      steps &#123;<br>        echo <span class="hljs-string">&#x27;正在推送文件...&#x27;</span><br>        sh <span class="hljs-string">&#x27;git fetch https://[Github用户名]:[Github令牌]@github.com/[Github用户名]/[Github博客仓库名].git&#x27;</span><br>        sh <span class="hljs-string">&#x27;git push -f https://[Github用户名]:[Github令牌]@github.com/[Github用户名]/[Github博客仓库名].git HEAD:master&#x27;</span><br>        echo <span class="hljs-string">&#x27;已完成文件推送.&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.设置触发规则：<br><img src="/../post-images/20200621105155.png"><br>7.在Gridea中同步一下，看看github上的仓库有没有同步吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一个坑：黑苹果主机换硬盘、迁移系统</title>
    <link href="/XopWfaM5l/"/>
    <url>/XopWfaM5l/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记得是生日那天，在京东为给自己买了块杂牌固态硬盘。</p></blockquote><h1 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h1><p>800闲鱼淘得的笔电用上了京东买的256g杂牌固态，但主机却用着128g的二手盘。用着新装的主机却越想越气，凭什么让性能差的二手笔记本享受如此待遇？遂，换！故是噩梦的开端。</p><h1 id="噩梦"><a href="#噩梦" class="headerlink" title="噩梦"></a>噩梦</h1><h2 id="1-硬盘对拷"><a href="#1-硬盘对拷" class="headerlink" title="1.硬盘对拷"></a>1.硬盘对拷</h2><p>换盘大业开始了，先是想到了祖传的硬盘对拷大法。<br>玩过装系统的应该知道Ghost，原理就是硬盘对拷，只不过前者打包成了文件可以传播。<br>两边都插上，进pe，直接打开DG，一键对拷美滋滋，连efi都省了配。</p><p>事实是，进入系统后储存空间没变化，256的盘成了128，打开磁盘工具删除未使用的分区，提示失败。很疑惑，用了半天突然死机，屏幕不动了，指针也卡住了。强制断电重启，不能启动，显示禁止符号。问相关群，答复是可能苹果系统会保存配置，不能强行对拷。</p><p>第一次，卒。</p><h2 id="2-时间机器"><a href="#2-时间机器" class="headerlink" title="2.时间机器"></a>2.时间机器</h2><p>这也是个坑。<br>第一次，格式化磁盘然后直接恢复，花了一个下午完成，最后得到个禁止符号。<br>第二次，格式化磁盘，安装系统，再时间机器恢复，能进系统了，待机一晚上，第二天不能开机，但键盘灯是亮的，推测又是死机了，重启仍然是禁止符号。<br>能看出黑白苹果还是有点差别的，再也不弄时间机器了，不能拯救系统的对我没啥用，删文件还删了一晚。</p><p>第二次，卒。</p><h2 id="3-全新安装"><a href="#3-全新安装" class="headerlink" title="3.全新安装"></a>3.全新安装</h2><p>我服了，我不想搞这么复杂，我只想好好用我的电脑。软件可以重装，资料可以再做，我停止了挣扎。<br>但问题还是出现了，依旧是走死机到禁止的流程，我才开始怀疑是硬盘问题。<br>因为笔电用的10.14.6，到主机则是10.15.4，考虑到这块硬盘可能对新系统水土不服，我安装了旧系统并配置了OC驱动。结果依旧，该走的流程一个不少。</p><p>第三次，卒。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>其实，128g够我用的了，删除点不必要的文件，把大文件搬到机械去，剩下40g还是挺好的。</p><h1 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h1><p>绝对不要买杂牌硬盘！京东服务还是很不错的，但换了货后问题依旧，说明这就是硬盘质量问题。哪怕当时多付个10块钱，我绝对有更好的体验。</p>]]></content>
    
    
    <categories>
      
      <category>黑苹果</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>把博客从github搬到coding</title>
    <link href="/github2coding/"/>
    <url>/github2coding/</url>
    
    <content type="html"><![CDATA[<p>虽然github很好，但百度蜘蛛不能抓取是个头疼的问题，而且不管是我上传还是访问，在国内的延迟十分感人，这在我开了cloudflare加速也是如此。想到博客这东西也不一定放到github上，估计没人会对你的博客源码感兴趣吧，最终还是搬到了coding。<br>可以说，这波体验非常好，由于coding依托腾讯云，服务器在国内，访问速度有很大提升。搬迁过程也十分顺利，不到1分钟DNS就全部解析好了。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录第一次黑苹果主机的组装经历</title>
    <link href="/HackintoshDiary/"/>
    <url>/HackintoshDiary/</url>
    
    <content type="html"><![CDATA[<blockquote><p>黑苹果，意外的简单。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>800闲鱼淘来的笔记本电脑，性能果然捉急，也被我装上黑苹果，录个屏直播CPU就跑满了，平时还跑个虚拟机，做项目也经常死机。五代的低压i5了，还在承受它这个年纪不该承受的我的摧残。<br>所以为了解放它，同时也为了放在团队实验室（为了正义！）被我敲代码，特意献祭1K5红包钱（真的一滴都没有了）组装台能跑视频剪辑虚拟机等大型应用的黑苹果主机。定位是小钢炮（是不是像做梦），毕竟可能需要经常搬运，实验室也不大，主机体积当然小一点比较好。<br>至于为什么是黑苹果…一入苹果深似海，在各设备的联动和iCloud中已经越陷越深无法自拔。</p><h1 id="配置一览"><a href="#配置一览" class="headerlink" title="配置一览"></a>配置一览</h1><table><tr><th>硬件</th><th>型号</th><th>钱</th><th>选择原因</th></tr><tr><td>CPU</td><td>Intel E3 1230 v2</td><td>250</td><td>考虑到预算紧张，就选志强洋垃圾了，记得这U五年前要一千，一年前要500，到现在250就能到买到，在闲鱼蹲会应该还能便宜，但为了质保这个心理安慰从淘宝入手。</td></tr><tr><td>主板</td><td>华南金牌B75</td><td>200<td>B75主板一二线基本是找不到新的了，毕竟是好多年前的板子，咬咬牙还是天猫上了华南的，毕竟人家还有保修不是？华南这板子好像没什么人试过黑苹果，感觉有得搞了。</td></td></tr><tr><td>显卡</td><td>迪兰恒进RX460 4g</td><td>300</td><td>这U没有核显，意味着必须上显卡了，黑苹果免驱的卡在闲鱼水涨船高，但在淘宝更便宜还带保，最重要的是这卡21厘米差一点就放不进机箱了。</td></tr><tr><td>内存</td><td>16g</td><td>300</td><td>三代内存在闲鱼已经算便宜了，8gx2塞满主板，直接花去两成预算。</td></tr><tr><td>电源</td><td>航嘉400W</td><td>200</td><td>再缩不能缩电源，不敢找闲鱼了，老老实实上全新的，寻思着400w应该够用了。（可能品控有点问题，第一次到的货有很大电流声）</td></tr><tr><td>机箱</td><td>乔思伯C2</td><td>100</td><td>机箱要小，所以在闲鱼找了家专门卖二手机箱的，看着挺小的，只不过风道可能需要调整下，不然很容易变闷罐。到手之后发现是个坑，限制显卡长度竟然如此之短，逼不得已换显卡（钱包-￥309）。</td></tr><tr><td>网卡</td><td>BCM94360CD</td><td>200</td><td>各设备联动就靠它了，随着黑苹果越来越多人玩，网卡方面价格真越来越高。我看到的涨多了一倍不止，说不定现在屯网卡明年就发了呢？</td></tr></table><h1 id="开整系统"><a href="#开整系统" class="headerlink" title="开整系统"></a>开整系统</h1><p>这次装机使用的是【19E266】版本，也可以参考写稿时黑果小兵最新的【<a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html">10.15.4 19E287 双EFI分区版</a>】。</p><ul><li><a href="https://github.com/LeUKi/Hackintosh-EFI-huanan_B75/blob/master/B75-Bios-setting.md">主板bios设置</a></li><li>镜像用balenaEtcher刷进U盘</li><li>在macos环境下用disktuil指令挂载U盘的EFI分区（Windows用第三方工具）</li><li>替换U盘的EFI文件（驱动完善差不多了，需要最后自取）</li><li>插到主板USB2.0接口，关闭应该关闭的BIOS选项，U盘启动</li><li>如果正确替换了EFI就能进到安装界面了，剩下的就是常规流程</li><li>安装完系统后，同样使用disktuil指令挂载安装盘的EFI分区，把U盘的EFI文件替换进去（这里可能涉及两次的分区挂卸载，在没有Clover configurator软件的时候只能这样手动输入）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">disktuil list<br>sudo disktuil mount diskXsX<br>sudo disktuil unmount diskXsX<br></code></pre></td></tr></table></figure></li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>弄到这里整个安装过程就结束了，可能是选择了很多免驱硬件的缘故，比想象中的简单，年度TODO✔️✔️️。<br>【<a href="https://github.com/LeUKi/Hackintosh-EFI-huanan_B75">我的EFI分享</a>】，希望能帮到你。如果你的显卡原生支援macOS，可在启动参数添加 <strong>-wegoff</strong> 以提升显卡性能。</p><h1 id="更新20200601"><a href="#更新20200601" class="headerlink" title="更新20200601"></a>更新20200601</h1><p>这次黑苹果组装经历踩了不少坑，<br>首先是网卡，在黑果小兵爆出有不良商家把4331冒充360cd后，一查直接踩雷。前者是不支持手表解锁的，当初我还傻傻一个劲问卖家为啥不行，现在长见识了，如果需要上驱动的网卡绝对是假的。如果你是真的360cd，请把efi中的网卡驱动删除。<br>然后是CPU，不是说买到假的了，而是在当初挑选硬件的时候没有仔细考虑，这款洋垃圾没有核显，所以随航是不能使用的。<br>电源方面我换了三个，京东服务是真的好，第一二次是嘉航，第三次价钱上振华，发现都有电流声，最后搞清楚不是产品问题，是家里电路设计问题。<br>这次一波三折， 下次配电脑应该是毕业后的事了吧。</p>]]></content>
    
    
    <categories>
      
      <category>黑苹果</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DW1820A黑苹果网卡简单折腾记录</title>
    <link href="/mu3Y7y8Gt/"/>
    <url>/mu3Y7y8Gt/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更新了，前面的方法不完美，请看后面！</p></blockquote><p>哪个男孩不想拥有一张完美的黑苹果网卡？（误）<br>无奈钱包瘪瘪，DW1830和DW1560对于目前学生的我实在太过昂贵。直到某天，在闲鱼上让我刷到了这“物美价廉”玩意。竟然只要1&#x2F;4的价钱，就能体验到msata免驱的WiFi加蓝牙。<br>到货装上后WiFi能免驱显示，但蓝牙却没反应。远景上也有人发过类似的帖子，顺着帖子找到了小兵大佬在19年8月份发的博客：<a href="https://blog.daliansky.net/DW1820A_BCM94350ZAE-driver-inserts-the-correct-posture.html">DW1820A…插入的正确姿势</a><br>来回折腾了几次，稳定版2.2.10文件和10.14测试版2.5.1文件在macOS1.14.6中只支持airdrop和handoff，并不能连接耳机和触控板等外设。只有10.15测试版2.5.1能近完美驱动这张网卡。<br><img src="/../post-images/1583073715577.png"><br><img src="/../post-images/1583073720233.png"><br><img src="/../post-images/1583073724880.png"><br>这张廉价网卡也是有缺点的，WiFi蓝牙共用2.4G会导致蓝牙不稳定，也不能连接5GWiFi的信号，虽然还能折腾下，但能用就行，觉得再弄下去没完没了。<br>记录几个还没有试过的方法：</p><ul><li>从Windows热重启到macOS</li><li>关机拔掉电源，等待5分钟再加电开机（但我这笔记本把电源不靠谱）</li></ul><hr><blockquote><p>20200328更新！找到了一个更好的方法，完美实现蓝牙功能，而且还解决了不能连接5Gwifi的问题，修复了开机几率掉蓝牙的问题。</p></blockquote><p>参考的是远景网友分享出来的方法：<a href="http://bbs.pcbeta.com/viewthread-1802647-1-1.html">关于DW1820A蓝牙连接问题解决方法，其它应该也可以。</a><br>很巧的是我买到的网卡和他的一样，在IOKitPersonalities添加子节后，把开头安装的2.5.1文件删除，重新下载稳定版本<a href="http://7.daliansky.net/DW1820A/BT_for_DW1820A_Ver.2.zip">v2.2.10</a>解压到<code>/EFI/CLOVER/kexts/Other</code>目录下，重启搞定！<br>需要注意的是远景教程里给出代码的第一行是多余的，重复添加可能会无法开机。<br>这里贴上我的Info.plist：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Broadcom<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>CFBundleIdentifier<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>IOClass<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>BroadcomBluetoothHostControllerUSBTransport<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>IOProviderClass<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>IOUSBHostDevice<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>idProduct<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>25618<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>idVendor<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>2652<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br></code></pre></td></tr></table></figure><p>至此，我离完美的黑苹果更进一步啦！如果你看到这，也祝你成功。</p>]]></content>
    
    
    <categories>
      
      <category>黑苹果</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一次在jQuery中input绑定keyup等事件的错误记录</title>
    <link href="/Fd2bot3Xf/"/>
    <url>/Fd2bot3Xf/</url>
    
    <content type="html"><![CDATA[<p><code>$(&quot;#s1arch&quot;).keyup(alert(123););</code><br>运行后发现直接运行了alert，找了好久没找到问题。<br>最后发现是格式错了，正确的写法应该是用一个匿名函数调用代码，而不是直接写代码。<br><code>$(&quot;#s1arch&quot;).keyup(function()&#123;alert(123);&#125;);</code><br>原因不明，未来找答案。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 给自己定个小目标</title>
    <link href="/my2020Goal/"/>
    <url>/my2020Goal/</url>
    
    <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> 拿一个不低于学校级的奖</li><li><input disabled="" type="checkbox"> 过英语四级</li><li><input checked="" disabled="" type="checkbox"> 组织一次集体活动</li><li><input disabled="" type="checkbox"> 做一套Gridea主题</li><li><input checked="" disabled="" type="checkbox"> 用技术本事赚到一笔钱</li><li><input checked="" disabled="" type="checkbox"> 攒钱买个电子产品</li><li><input checked="" disabled="" type="checkbox"> 换一台舒服的电脑</li><li><input checked="" disabled="" type="checkbox"> 学会Hackintosh（至少会安装）</li></ul><p>9个小目标，期待达成！</p>]]></content>
    
    
    <categories>
      
      <category>小目标</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Minecraft(Java1.12.2)服务器中“删除”作浮空字盔甲架的新方法</title>
    <link href="/TCGjGElL3/"/>
    <url>/TCGjGElL3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单机作弊模式下也可参考！急的跳过前言看后面</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用summon指令生成了一个浮空字，原理是生成一个隐形的盔甲架并把其名字做常显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/summon minecraft:armor_stand ~ ~<span class="hljs-number">2</span> ~ &#123;Marker:<span class="hljs-number">1</span>,NoGravity:<span class="hljs-number">1</span>,Invisible:<span class="hljs-number">1</span>,CustomNameVisible:<span class="hljs-number">1</span>,CustomName:<span class="hljs-string">&quot;这是串浮空的字&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>但当我们想删除它时，输入 <strong>&#x2F;kill @e[type&#x3D;armor_stand,c&#x3D;10]</strong> 指令可能会出现 <strong>Error: Player not found.</strong> 的报错论坛也有说用 <strong>&#x2F;killall</strong> 指令的，但实测无用。</p><p>网上也没用人给出删除的办法，似乎这是个bug。有人给出下下策，删除区块甚至删除存档。我想这条生成指令正常玩家大概率不会用到。使用的大多数是地图制作者和服务器op，前者可以回档重来，后者一般用相关插件管理，用的人寥寥无几。似乎没有删除的需求，但真遇上了也是件恶心的事，所以下面给出方法。</p><h1 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h1><p>利用<strong>entitydata</strong>指令更改实体的属性参数，这是1.8版本中加入的指令，一般用作给全地图怪物加装备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/entitydata <span class="hljs-meta">@e</span>[type=Armor_Stand,r=<span class="hljs-number">10</span>] &#123;CustomNameVisible:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>将CustomNameVisible(名字可见度)设置为不可见(0)，实际上这个实体并没有被删除，而是完全隐藏了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行列式与矩阵的区别-线性代数学习小记</title>
    <link href="/fGZB0vOKh/"/>
    <url>/fGZB0vOKh/</url>
    
    <content type="html"><![CDATA[<ol><li>矩阵是一个表格，行数和列数可以不一样；而行列式是一个数，且行数必须等于列数。只有方阵才可以定义它的行列式，而对于长方阵不能定义它的行列式。</li><li>两个矩阵相等是指对应元素都相等；两个行列式相等不要求对应元素都相等，甚至阶数也可以不一样，只要运算代数和的结果一样就行了。</li><li>两矩阵相加是将各对应元素相加；两行列式相加，是将运算结果相加，在特殊情况下(比如有行或列相同)，只能将一行(或列)的元素相加，其余元素照写。</li><li>数乘矩阵是指该数乘以矩阵的每一个元素；而数乘行列式，只能用此数乘行列式的某一行或列，提公因数也如此。</li><li>矩阵经初等变换，其秩不变；行列式经初等变换，其值可能改变：换法变换要变号，倍法变换差倍数；消法变换不改变。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高数课绝对不能睡啊啊啊啊</title>
    <link href="/qouTlDpCi/"/>
    <url>/qouTlDpCi/</url>
    
    <content type="html"><![CDATA[<p>现在欠的债，你会花更多时间补回来的，相信我！</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于C语言printf函数的易错点</title>
    <link href="/yZ1fm-el0/"/>
    <url>/yZ1fm-el0/</url>
    
    <content type="html"><![CDATA[<p>截取了这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,++a,a);<br></code></pre></td></tr></table></figure><p>会输出什么呢？<br>答案不是<code>2,2</code>，而是<code>2,1</code>。<br>原来printf函数是同赋值变量具有右结合性的，而这在教材中鲜少提到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于C语言数组排序的一点想法</title>
    <link href="/HiBqxtmMW/"/>
    <url>/HiBqxtmMW/</url>
    
    <content type="html"><![CDATA[<p>普遍的方法是先用for语句输入数组的值，再用for与for的嵌套语句实现历遍并排序，这一整套下来使用了三次for语句，特别是最后的两个让人头大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span><span class="hljs-number">-1</span>; i++)&#123; <br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span><span class="hljs-number">-1</span>-i; j++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j+<span class="hljs-number">1</span>])&#123;<br>            temp = nums[j];<br>            nums[j] = nums[j+<span class="hljs-number">1</span>];<br>            nums[j+<span class="hljs-number">1</span>] = temp;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>我的想法是，不如在输入后立刻排序，减少了语句使用，而且更加直观。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>],i,j,temp;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">19</span>;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第%d个数:&quot;</span>,i+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">for</span>(j=i;j&gt;<span class="hljs-number">0</span>;j--)<br>            <span class="hljs-keyword">if</span>(a[j]&lt;a[j<span class="hljs-number">-1</span>])&#123;temp=a[j];a[j]=a[j<span class="hljs-number">-1</span>];a[j<span class="hljs-number">-1</span>]=temp;&#125;&#125;<br></code></pre></td></tr></table></figure><p>其实两者差别不大，结合第后一个方法很容易就把前一个看懂了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学团支书，真的不一样...</title>
    <link href="/6pu2g-gw-/"/>
    <url>/6pu2g-gw-/</url>
    
    <content type="html"><![CDATA[<p>初中高中所见的团支书，很清闲，很安逸。到大学，信心满满当选上团支书，才知道理想和现实天差地别。<br>可能海大是特例吧，海大团支书的黑暗11月不是吹的，“精品团日”、“活力在基层”、“团支书培训班”，全部活动都堆在这两个月，每天睡觉都在想怎么搞活动、怎么把任务分配下去、活动地点活动时间怎么安排。院团支书群和培训班群需要时刻留意通知，一有活动就需要更进处理。每天的学习时间总是被挤压，参加社团和学生组织根本不敢想，休闲娱乐已然成为奢侈。<br>团支书最害怕的不是上级任务的多少，而是团支部团员们不配合，上级不批准，团支书夹在中间两头难，最后这锅还得自己背。目前感觉有些苗头，希望以后不要真的遇到。🙏<br>团支书大群里常有人吐苦水，只能说，自己竞选上的团支书，跪着也要做好。  </p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>往后一旬，请多指教！</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>  这些年陆陆续续整了几十个域名，七八个空间，四五台主机，两三个博客系统，很遗憾没一个能长久。到了高三，巨大学习压力使我不得不放弃。到如今高考结束，长大成年了，却发现自己没有了当年折腾的热情。直到某天逛到一个Github托管网站的贴，下定决心，再次出发。<br>  Github是个好东西，原谅我玩了这么久才意识到，把网站托管在这，永久运行，这是以前穷学生的我不敢想象的。域名当然也可以用免费的一二级域名，诸如.tk、.eu.org，但始终不是属于自己，被人拿捏的感觉始终是难受的。考虑再三，还是入了一个，正好阿里云搞优惠，170元10年的.fun域名，足够长也足够划算。<br>  往后10年，我想在此写写学习上的心得、生活中的趣事，不为谁而写作，只希望10年后的我能回看这一旬青春，一路成长。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
